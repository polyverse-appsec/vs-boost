{
  "cells": [
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "0",
      "value": "import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport * as boostnb from \"./jupyter_notebook\";\nimport { getOrCreateGuideline } from \"./extension\";\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 4
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "1",
      "value": "\nimport {\n    BoostPerformanceFunctionKernel,\n    performanceFunctionKernelName,\n} from \"./performance_function_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 6
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "2",
      "value": "import {\n    BoostPerformanceKernel,\n    performanceKernelName,\n} from \"./performance_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 10
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "3",
      "value": "\nimport { BoostAnalyzeKernel, analyzeKernelName } from \"./analyze_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 3,
        "type": "originalCode",
        "lineNumberBase": 15
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "4",
      "value": "import {\n    BoostAnalyzeFunctionKernel,\n    analyzeFunctionKernelName,\n} from \"./analyze_function_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 4,
        "type": "originalCode",
        "lineNumberBase": 16
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "5",
      "value": "import { BoostTestgenKernel, testgenKernelName } from \"./testgen_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 5,
        "type": "originalCode",
        "lineNumberBase": 20
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "6",
      "value": "import { BoostConvertKernel, convertKernelName } from \"./convert_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 6,
        "type": "originalCode",
        "lineNumberBase": 21
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "7",
      "value": "import {\n    BoostComplianceKernel,\n    complianceKernelName,\n} from \"./compliance_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 7,
        "type": "originalCode",
        "lineNumberBase": 22
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "8",
      "value": "import {\n    BoostComplianceFunctionKernel,\n    complianceFunctionKernelName,\n} from \"./compliance_function_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 8,
        "type": "originalCode",
        "lineNumberBase": 26
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "9",
      "value": "import { BoostExplainKernel, explainKernelName } from \"./explain_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 9,
        "type": "originalCode",
        "lineNumberBase": 30
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "10",
      "value": "import {\n    BoostCodeGuidelinesKernel,\n    codeGuidelinesKernelName,\n} from \"./codeguidelines_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 10,
        "type": "originalCode",
        "lineNumberBase": 31
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "11",
      "value": "import {\n    BoostArchitectureBlueprintKernel,\n    blueprintKernelName,\n} from \"./blueprint_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 11,
        "type": "originalCode",
        "lineNumberBase": 35
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "12",
      "value": "import {\n    BoostCustomProcessKernel,\n    customProcessCellMarker,\n} from \"./custom_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 12,
        "type": "originalCode",
        "lineNumberBase": 39
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "13",
      "value": "import {\n    BoostFlowDiagramKernel,\n    flowDiagramKernelName,\n} from \"./flowdiagram_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 13,
        "type": "originalCode",
        "lineNumberBase": 43
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "14",
      "value": "import { SummarizeKernel, summarizeKernelName } from \"./summary_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 14,
        "type": "originalCode",
        "lineNumberBase": 47
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "15",
      "value": "import { ControllerOutputType } from \"./controllerOutputTypes\";\n",
      "kind": 2,
      "metadata": {
        "id": 15,
        "type": "originalCode",
        "lineNumberBase": 48
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "16",
      "value": "\nimport { BoostSummaryViewProvider, summaryViewType } from \"./summary_view\";\n",
      "kind": 2,
      "metadata": {
        "id": 16,
        "type": "originalCode",
        "lineNumberBase": 50
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "17",
      "value": "import { BoostStartViewProvider } from \"./start_view\";\n",
      "kind": 2,
      "metadata": {
        "id": 17,
        "type": "originalCode",
        "lineNumberBase": 51
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "18",
      "value": "import { BoostChatViewProvider } from \"./chat_view\";\n",
      "kind": 2,
      "metadata": {
        "id": 18,
        "type": "originalCode",
        "lineNumberBase": 52
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "19",
      "value": "import { boostNotebookToFileSummaryItem } from \"./BoostProjectData\";\n",
      "kind": 2,
      "metadata": {
        "id": 19,
        "type": "originalCode",
        "lineNumberBase": 53
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "20",
      "value": "\nimport {\n    getBoostFile,\n    BoostFileType,\n    parseFunctionsFromFile,\n    buildVSCodeIgnorePattern,\n    newErrorFromItemData,\n    createOrOpenNotebookFromSourceFile,\n    _syncProblemsInCell,\n    createOrOpenSummaryNotebookFromSourceFile,\n    BoostCommands,\n    findCellByKernel,\n    cleanCellOutput,\n    boostActivityBarId,\n} from \"./extension\";\n",
      "kind": 2,
      "metadata": {
        "id": 20,
        "type": "originalCode",
        "lineNumberBase": 55
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "21",
      "value": "import { BoostUserAnalysisType } from \"./userAnalysisType\";\n",
      "kind": 2,
      "metadata": {
        "id": 21,
        "type": "originalCode",
        "lineNumberBase": 69
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "22",
      "value": "\nimport { BoostContentSerializer } from \"./serializer\";\n",
      "kind": 2,
      "metadata": {
        "id": 22,
        "type": "originalCode",
        "lineNumberBase": 71
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "23",
      "value": "import { BoostConfiguration } from \"./boostConfiguration\";\n",
      "kind": 2,
      "metadata": {
        "id": 23,
        "type": "originalCode",
        "lineNumberBase": 72
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "24",
      "value": "import { boostLogging } from \"./boostLogging\";\n",
      "kind": 2,
      "metadata": {
        "id": 24,
        "type": "originalCode",
        "lineNumberBase": 73
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "25",
      "value": "import { KernelControllerBase } from \"./base_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 25,
        "type": "originalCode",
        "lineNumberBase": 74
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "26",
      "value": "import {\n    updateBoostStatusColors,\n    registerCustomerPortalCommand,\n    setupBoostStatus,\n    preflightCheckForCustomerStatus,\n} from \"./portal\";\n",
      "kind": 2,
      "metadata": {
        "id": 26,
        "type": "originalCode",
        "lineNumberBase": 75
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "27",
      "value": "import { generatePDFforNotebook } from \"./convert_pdf\";\n",
      "kind": 2,
      "metadata": {
        "id": 27,
        "type": "originalCode",
        "lineNumberBase": 81
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "28",
      "value": "import { generateMarkdownforNotebook } from \"./convert_markdown\";\n",
      "kind": 2,
      "metadata": {
        "id": 28,
        "type": "originalCode",
        "lineNumberBase": 82
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "29",
      "value": "import { generateHTMLforNotebook } from \"./convert_html\";\n",
      "kind": 2,
      "metadata": {
        "id": 29,
        "type": "originalCode",
        "lineNumberBase": 83
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "30",
      "value": "import { BoostProjectData } from \"./BoostProjectData\";\n",
      "kind": 2,
      "metadata": {
        "id": 30,
        "type": "originalCode",
        "lineNumberBase": 84
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "31",
      "value": "import { IncompatibleVersionException } from \"./incompatibleVersionException\";\n",
      "kind": 2,
      "metadata": {
        "id": 31,
        "type": "originalCode",
        "lineNumberBase": 85
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "32",
      "value": "import { emptyProjectData } from \"./boostprojectdata_interface\";\n",
      "kind": 2,
      "metadata": {
        "id": 32,
        "type": "originalCode",
        "lineNumberBase": 86
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "33",
      "value": "import { BoostMarkdownViewProvider } from \"./markdown_view\";\n",
      "kind": 2,
      "metadata": {
        "id": 33,
        "type": "originalCode",
        "lineNumberBase": 87
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "34",
      "value": "\nimport instructions from \"./instructions.json\";\nimport {\n    BoostQuickBlueprintKernel,\n    quickBlueprintKernelName,\n} from \"./quick_blueprint_controller\";\n",
      "kind": 2,
      "metadata": {
        "id": 34,
        "type": "originalCode",
        "lineNumberBase": 90
      }
    },
    {
      "outputs": [],
      "languageId": "typescript",
      "id": "35",
      "value": "\nexport class BoostExtension {\n    // for state, we keep it in a few places\n    // 1. here, in the extension object.  this should really just be transient state like UI objects\n    // 2. in the globalState object.  this is syncronized with the cloud, so stuff like the organization should be kept there\n    // 3. in the extension configuration. this is more 'permanent' state.\n    public statusBar: vscode.StatusBarItem | undefined;\n    kernels: Map<string, KernelControllerBase> = new Map<\n        string,\n        KernelControllerBase\n    >();\n\n    public summaryViewProvider: BoostSummaryViewProvider | undefined;\n\n    public readonly sampleGuidelineRegEx =\n        /^# Enter Your \\w+ Guidelines Here\\n\\nYou can describe your goals, constraints, or hints for analysis$/;\n\n    public blueprintPanel: BoostMarkdownViewProvider | undefined;\n\n    constructor(context: vscode.ExtensionContext) {\n        // ensure logging is shutdown\n        context.subscriptions.push(boostLogging);\n\n        this._setupBoostProjectDataLifecycle(context);\n\n        let problems = this._setupDiagnosticProblems(context);\n\n        this.setupNotebookEnvironment(context, problems);\n\n        this.registerCreateNotebookCommand(context, problems);\n\n        this.registerRefreshProjectDataCommands(context);\n\n        registerCustomerPortalCommand(context);\n\n        setupBoostStatus(context, this);\n\n        // register the select language command\n        this.setupKernelCommandPicker(context);\n        this.setupKernelStatus(context);\n\n        // register the select language command\n        this.setupOutputLanguagePicker(context);\n\n        // register the select framework command\n        this.setupTestFrameworkPicker(context);\n\n        this.registerOpenCodeFile(context);\n\n        this.registerProjectLevelCommands(context);\n\n        this.registerFileRightClickAnalyzeCommand(context);\n\n        this.registerFolderRightClickAnalyzeCommand(context);\n\n        this.registerFolderRightClickOutputCommands(context);\n\n        this.registerSourceCodeRightClickCommands(context);\n\n        this.registerShowGuidelinesCommand(context);\n\n        this.setupDashboard(context);\n\n        boostLogging.log(\"Activated Boost Notebook Extension\");\n\n        if (BoostConfiguration.logLevel === \"debug\") {\n            boostLogging.info(\"Polyverse Boost is now active\");\n        }\n    }\n\n    private _setupBoostProjectDataLifecycle(context: vscode.ExtensionContext) {\n        let disposable = vscode.workspace.onDidChangeWorkspaceFolders(\n            this.workspaceFoldersChanged\n        );\n        context.subscriptions.push(disposable);\n\n        disposable = vscode.workspace.onDidChangeConfiguration(\n            this.configurationChanged.bind(this)\n        );\n        context.subscriptions.push(disposable);\n\n        // initialize once on startup... especially since single-folder projects will never fire the events\n        this.refreshBoostProjectsData();\n    }\n\n    _boostProjectData = new Map<vscode.Uri, BoostProjectData>();\n    // FUTURE: We aren't syncing with files being added or removed from the project, or changes in those files\n    private workspaceFoldersChanged(\n        changeEvent: vscode.WorkspaceFoldersChangeEvent\n    ) {\n        if (this) {\n            this.refreshBoostProjectsData();\n        }\n    }\n\n    private configurationChanged(changeEvent: vscode.ConfigurationChangeEvent) {\n        if (this) {\n            this.refreshBoostProjectsData();\n        }\n    }\n\n    async refreshBoostProjectsData(): Promise<void> {\n        return new Promise<void>(async (resolve, reject) => {\n            try {\n                // future improvement - use changeEvent.added and changeEvent.removed to add or remove folders rather than resyncing everything\n\n                const folders = vscode.workspace.workspaceFolders;\n                if (!folders || folders.length === 0) {\n                    this._boostProjectData.clear();\n                    return;\n                }\n\n                for (const workspaceFolder of folders) {\n                    await this.refreshProjectDataCacheForWorkspaceFolder(workspaceFolder);\n                }\n\n                // unload/release any boost project data for folders that are no longer in the workspace\n                this._boostProjectData.forEach(\n                    (_value: BoostProjectData, workspaceFolder: vscode.Uri) => {\n                        if (\n                            !folders.filter((thisFolder) => {\n                                return thisFolder.uri === workspaceFolder;\n                            })\n                        ) {\n                            this._boostProjectData.delete(workspaceFolder);\n                        }\n                    }\n                );\n                resolve();\n            } catch (error) {\n                boostLogging.error(\n                    `Error refreshing Boost Project data: ${error}`\n                );\n                reject(error);\n            }\n        });\n    }\n\n    async refreshProjectDataCacheForWorkspaceFolder(\n        workspaceFolder: vscode.WorkspaceFolder\n    ) {\n        // Check if boost project data already exists\n        let boostProjectData = this._boostProjectData.get(workspaceFolder.uri);\n        let boostProjectUri = getBoostFile(\n            workspaceFolder.uri,\n            BoostFileType.status\n        );\n\n        if (boostProjectData) {\n            // Refresh project data and save boost project data\n            await this.refreshProjectData(boostProjectData, workspaceFolder.uri);\n            boostProjectData.save(boostProjectUri.fsPath);\n        }\n\n        // Create new boost project data if it doesn't exist\n        boostProjectData = new BoostProjectData();\n\n        if (!fs.existsSync(boostProjectUri.fsPath)) {\n            // Create new boost project file\n            boostLogging.debug(\n                `No boost project file found at ${boostProjectUri.fsPath} - creating new one`\n            );\n            await this.initializeFromWorkspaceFolder(\n                boostProjectData,\n                workspaceFolder.uri\n            );\n        } else {\n            try {\n                // Load existing boost project data\n                boostProjectData.load(boostProjectUri.fsPath);\n            } catch (error) {\n                if (error instanceof IncompatibleVersionException) {\n                    // Create new boost project file if incompatible version is found\n                    boostLogging.info(\n                        `Older version ${error.actualVersion} of Boost Project Data Cache found ${boostProjectUri.fsPath} - creating cache at version ${error.expectedVersion}`\n                    );\n                    boostProjectData = undefined;\n                } else if (error instanceof SyntaxError) {\n                    // Create new boost project file if JSON is malformed\n                    boostLogging.info(\n                        `Existing Boost Project Data Cache corrupted at ${boostProjectUri.fsPath} - creating new cache`\n                    );\n                    boostProjectData = undefined;\n                } else {\n                    throw error;\n                }\n            } finally {\n                // Recreate boost project data from scratch if failed to load\n                if (!boostProjectData) {\n                    boostProjectData = new BoostProjectData();\n                    fs.renameSync(\n                        boostProjectUri.fsPath,\n                        boostProjectUri.fsPath + \".previous\"\n                    );\n                    await this.initializeFromWorkspaceFolder(\n                        boostProjectData,\n                        workspaceFolder.uri\n                    );\n                }\n            }\n\n            // Set project name in boost project data if not already set\n            if (!boostProjectData.summary.projectName) {\n                boostProjectData.summary.projectName = path.basename(\n                    workspaceFolder.uri.fsPath\n                );\n                boostProjectData.flushToFS();\n            }\n        }\n\n        // Update boost project data map with new boost project data\n        this._boostProjectData.set(workspaceFolder.uri, boostProjectData);\n        return boostProjectData;\n    }\n\n    async refreshProjectData(\n        boostProjectData: BoostProjectData,\n        workspaceFolder: vscode.Uri\n    ) {\n        const issues: string[] = [];\n        try {\n            if (!boostProjectData.summary.summaryUrl) {\n                const summaryPath = getBoostFile(\n                    workspaceFolder,\n                    BoostFileType.summary\n                ).fsPath;\n                const relativeSummaryPath = path.relative(\n                    workspaceFolder.fsPath,\n                    summaryPath\n                );\n                boostProjectData.summary.summaryUrl =\n                    \"./\" + relativeSummaryPath;\n            }\n            if (\n                !fs.existsSync(\n                    path.resolve(\n                        workspaceFolder.fsPath,\n                        boostProjectData.summary.summaryUrl\n                    )\n                )\n            ) {\n                issues.push(\n                    `No summary file found at ${boostProjectData.summary.summaryUrl}`\n                );\n            }\n            await this.getBoostFilesForFolder(\n                workspaceFolder,\n                boostProjectData,\n                true\n            );\n        } catch (error) {\n            boostLogging.debug(\n                `Error refreshing Boost Project data for ${workspaceFolder.fsPath}: ${error}`\n            );\n            issues.push(\n                `Error refreshing Boost Project data for ${workspaceFolder.fsPath}: ${error}`\n            );\n        } finally {\n            // store the total number of issues no matter what happened\n            boostProjectData.summary.issues = issues;\n        }\n    }\n\n    async initializeFromWorkspaceFolder(\n        boostProjectData: BoostProjectData,\n        workspaceFolder: vscode.Uri\n    ) {\n        Object.assign(boostProjectData, emptyProjectData);\n        boostProjectData.dataFormatVersion = BoostConfiguration.version;\n\n        boostProjectData.summary.summaryUrl = getBoostFile(\n            workspaceFolder,\n            BoostFileType.summary\n        ).fsPath;\n        await this.getBoostFilesForFolder(\n            workspaceFolder,\n            boostProjectData,\n            true\n        );\n\n        boostProjectData.summary.issues = [\"No issues found\"];\n        boostProjectData.summary.projectName = path.basename(\n            workspaceFolder.fsPath\n        );\n\n        boostProjectData.save(\n            getBoostFile(workspaceFolder, BoostFileType.status).fsPath\n        );\n    }\n\n    public getBoostProjectData(): any {\n        let workspaceFolder = vscode.workspace.workspaceFolders?.[0].uri;\n        if (!workspaceFolder) {\n            return emptyProjectData;\n        }\n\n        return this._boostProjectData.get(workspaceFolder);\n    }\n\n    async getBoostFilesForFolder(\n        workspaceFolder: vscode.Uri,\n        boostProjectData: BoostProjectData,\n        deepScan: boolean = false\n    ): Promise<void> {\n        let searchPattern = new vscode.RelativePattern(\n            workspaceFolder.fsPath,\n            \"**/*.*\"\n        );\n        let ignorePattern = await buildVSCodeIgnorePattern();\n        boostLogging.debug(\n            \"Skipping source files of pattern: \" + (ignorePattern ?? \"none\")\n        );\n        const files = await vscode.workspace.findFiles(\n            searchPattern,\n            ignorePattern\n                ? new vscode.RelativePattern(workspaceFolder, ignorePattern)\n                : \"\"\n        );\n\n        let total = 0;\n        let exists = 0;\n\n        for (const file of files) {\n            total++;\n            const boostFileUri = getBoostFile(file);\n            const fileExists = fs.existsSync(boostFileUri.fsPath);\n\n            if (!fileExists) {\n                continue;\n            }\n            exists++;\n            if (!deepScan) {\n                continue;\n            }\n            const boostNotebook = new boostnb.BoostNotebook();\n            boostNotebook.load(boostFileUri.fsPath);\n\n            //get the summary of the notebook file\n            const filesummary = boostNotebookToFileSummaryItem(boostNotebook);\n\n            //now add it to boostprojectdata\n            let relativePath = path.relative(\n                workspaceFolder.fsPath,\n                file.fsPath\n            );\n            boostProjectData.updateWithFileSummary(filesummary, relativePath);\n        }\n        boostProjectData.summary.filesToAnalyze = total;\n        boostProjectData.summary.filesAnalyzed = exists;\n    }\n\n    _setupDiagnosticProblems(\n        context: vscode.ExtensionContext\n    ): vscode.DiagnosticCollection {\n        // create the Problems collection\n        const problems = vscode.languages.createDiagnosticCollection(\n            boostnb.NOTEBOOK_TYPE + \".problems\"\n        );\n\n        // whenever we open a boost notebook, we need to re-sync the problems (in case errors were persisted with it)\n        vscode.workspace.onDidOpenNotebookDocument((event) => {\n            if (event.notebookType !== boostnb.NOTEBOOK_TYPE) {\n                return;\n            }\n\n            event.getCells().forEach((cell) => {\n                cell.outputs.forEach((output) => {\n                    output.items.forEach((item) => {\n                        let thisItem = item as vscode.NotebookCellOutputItem;\n                        if (\n                            thisItem.mime !==\n                            \"application/vnd.code.notebook.error\"\n                        ) {\n                            return;\n                        }\n\n                        // we use the kernel controller that was attached to this output to deserialize the error\n                        // If we can't find the kernel controller metadata, then just use the explain controller\n                        this.kernels.forEach(\n                            (\n                                value: KernelControllerBase,\n                                key: string,\n                                kernels: Map<string, KernelControllerBase>\n                            ) => {\n                                if (\n                                    value !== output.metadata?.outputType ??\n                                    ControllerOutputType.explain\n                                ) {\n                                    return;\n                                }\n\n                                let deserializedError = newErrorFromItemData(\n                                    thisItem.data\n                                );\n\n                                value.deserializeErrorAsProblems(\n                                    cell,\n                                    deserializedError\n                                );\n                            }\n                        );\n                    });\n                });\n                _syncProblemsInCell(cell, problems);\n            });\n        });\n\n        // when the notebook is closed, we need to clear its problems as well\n        //    note that problems are tied to the cells, not the notebook\n        vscode.workspace.onDidCloseNotebookDocument((event) => {\n            if (event.notebookType !== boostnb.NOTEBOOK_TYPE) {\n                return;\n            }\n\n            event.getCells().forEach((cell) => {\n                problems.forEach((value, key) => {\n                    boostLogging.debug(\n                        `Evaluating ${\n                            value.fsPath\n                        } against ${cell.document.uri.toString()}`\n                    );\n                });\n                problems.delete(cell.document.uri);\n            });\n        });\n\n        // Register an event listener for the onDidClearOutput event\n        const notebookChangeHandler: vscode.Disposable =\n            vscode.workspace.onDidChangeNotebookDocument((event) => {\n                // when a cell changes\n                for (const cellChange of event.cellChanges) {\n                    // if no outputs changed, skip it\n                    if (!cellChange.outputs) {\n                        continue;\n                    }\n\n                    _syncProblemsInCell(cellChange.cell, problems);\n                }\n\n                // when content in a cell changes - look for full deletions of cell\n                // Loop through each changed cell content\n                for (const changedContent of event.contentChanges) {\n                    for (const cell of changedContent.removedCells) {\n                        _syncProblemsInCell(cell, problems, true);\n                    }\n                }\n            });\n\n        // Dispose the event listener when it is no longer needed\n        context.subscriptions.push(notebookChangeHandler);\n\n        return problems;\n    }\n\n    kernelCommand: string | undefined = undefined;\n    setupKernelCommandPicker(context: vscode.ExtensionContext) {\n        context.subscriptions.push(\n            vscode.commands.registerCommand(\n                boostnb.NOTEBOOK_TYPE + \".selectKernelCommand\",\n                async () => {\n                    // Use the vscode.window.showQuickPick method to let the user select kernel\n                    let availableKernelItems: any[] = [];\n                    let defaultKernelChoice: string | undefined = undefined;\n                    this.kernels.forEach((kernel: KernelControllerBase) => {\n                        availableKernelItems.push({\n                            label: kernel.command,\n                            description:\n                                \"Polyverse Boost: \" + kernel.kernelLabel,\n                            details: kernel.description,\n                        });\n                        if (\n                            kernel.id ===\n                            BoostConfiguration.currentKernelCommand\n                        ) {\n                            defaultKernelChoice = kernel.command;\n                        }\n                    });\n\n                    const kernelChoice = await vscode.window.showQuickPick(\n                        availableKernelItems,\n                        {\n                            title: \"Choose a Kernel to use for processing of all Boost Notebooks and Cells\",\n                            canPickMany: false,\n                            placeHolder:\n                                BoostConfiguration.currentKernelCommand ??\n                                \"Select Boost Kernel\",\n                            matchOnDescription: true,\n                            matchOnDetail: true,\n                        }\n                    );\n                    if (!kernelChoice) {\n                        return;\n                    }\n                    if (!this.kernels.get(kernelChoice.label)) {\n                        boostLogging.error(\n                            `Invalid or unavailable Boost command: ${kernelChoice.label}`\n                        );\n                        return;\n                    }\n                    // store the kernel as current config command - for offline processing\n                    this.kernelCommand = kernelChoice.label;\n                    BoostConfiguration.currentKernelCommand = this.kernels.get(\n                        kernelChoice.label\n                    )?.id as string;\n                    if (this.kernelStatusBar) {\n                        this.kernelStatusBar.text = `Boost Command: ${kernelChoice.label}`;\n                    }\n                }\n            )\n        );\n    }\n\n    kernelStatusBar: vscode.StatusBarItem | undefined = undefined;\n\n    setupKernelStatus(context: vscode.ExtensionContext) {\n        const kernelStatusBar = vscode.window.createStatusBarItem(\n            vscode.StatusBarAlignment.Left,\n            9\n        );\n        this.kernelStatusBar = kernelStatusBar;\n\n        const kernelCommand = BoostConfiguration.currentKernelCommand;\n\n        this.kernelStatusBar.text = \"Select Boost Kernel\";\n        this.kernels.forEach((kernel: KernelControllerBase) => {\n            if (kernel.id !== kernelCommand) {\n                return;\n            }\n            if (this.kernelStatusBar) {\n                this.kernelStatusBar.text = `Boost Command: ${kernel.command}`;\n            }\n        });\n        // if we have a kernel command specified, but didn't match it, the kernel choice is invalid\n        if (\n            kernelCommand &&\n            kernelCommand !== \"\" &&\n            this.kernelStatusBar.text === \"Select Boost Kernel\"\n        ) {\n            boostLogging.error(\n                `Invalid Boost command: ${BoostConfiguration.currentKernelCommand} - set a valid Boost kernel name in User Settings or reset to default`\n            );\n        }\n\n        this.kernelStatusBar.command =\n            boostnb.NOTEBOOK_TYPE + \".selectKernelCommand\";\n        this.kernelStatusBar.show();\n        context.subscriptions.push(this.kernelStatusBar);\n    }\n\n    private setupTestFrameworkPicker(context: vscode.ExtensionContext) {\n        context.subscriptions.push(\n            vscode.commands.registerCommand(\n                boostnb.NOTEBOOK_TYPE + \".selectTestFramework\",\n                async () => {\n                    //first get the framework from the metadata\n                    const currentNotebook =\n                        vscode.window.activeNotebookEditor?.notebook;\n                    let framework = \"pytest\";\n                    if (currentNotebook) {\n                        framework = currentNotebook.metadata.testFramework;\n                    }\n                    // Use the vscode.window.showQuickPick method to let the user select a framework\n                    framework =\n                        (await vscode.window.showInputBox({\n                            prompt: \"Enter a testing framework\",\n                            placeHolder: framework,\n                        })) ?? framework;\n                    //put the framework in the metadata\n                    if (currentNotebook) {\n                        const edit = new vscode.WorkspaceEdit();\n                        edit.set(currentNotebook.uri, [\n                            vscode.NotebookEdit.updateNotebookMetadata({\n                                testFramework: framework,\n                            }),\n                        ]);\n                        await vscode.workspace.applyEdit(edit);\n                    }\n                }\n            )\n        );\n    }\n\n    private setupOutputLanguagePicker(context: vscode.ExtensionContext) {\n        context.subscriptions.push(\n            vscode.commands.registerCommand(\n                boostnb.NOTEBOOK_TYPE + \".selectOutputLanguage\",\n                async () => {\n                    // Use the vscode.window.showQuickPick method to let the user select a language\n                    const language = await vscode.window.showQuickPick(\n                        [\n                            \"python\",\n                            \"ruby\",\n                            \"swift\",\n                            \"rust\",\n                            \"javascript\",\n                            \"typescript\",\n                            \"csharp\",\n                        ],\n                        {\n                            canPickMany: false,\n                            placeHolder: \"Select a language\",\n                        }\n                    );\n                    //put the language in the metadata\n                    const editor = vscode.window.activeNotebookEditor;\n\n                    const currentNotebook =\n                        vscode.window.activeNotebookEditor?.notebook;\n                    if (currentNotebook) {\n                        const edit = new vscode.WorkspaceEdit();\n                        edit.set(currentNotebook.uri, [\n                            vscode.NotebookEdit.updateNotebookMetadata({\n                                outputLanguage: language,\n                            }),\n                        ]);\n                        await vscode.workspace.applyEdit(edit);\n                    }\n                }\n            )\n        );\n    }\n\n    setupNotebookEnvironment(\n        context: vscode.ExtensionContext,\n        collection: vscode.DiagnosticCollection\n    ) {\n        context.subscriptions.push(\n            vscode.workspace.registerNotebookSerializer(\n                boostnb.NOTEBOOK_TYPE,\n                new BoostContentSerializer(),\n                { transientOutputs: false }\n            )\n        );\n        let kernelTypes = [\n            BoostConvertKernel,\n            BoostExplainKernel,\n            BoostAnalyzeKernel,\n            BoostTestgenKernel,\n            BoostComplianceKernel,\n            BoostCodeGuidelinesKernel,\n            BoostArchitectureBlueprintKernel,\n            BoostFlowDiagramKernel,\n            BoostCustomProcessKernel,\n            SummarizeKernel,\n            BoostAnalyzeFunctionKernel,\n            BoostComplianceFunctionKernel,\n            BoostPerformanceFunctionKernel,\n            BoostPerformanceKernel,\n        ];\n        // if in dev mode, register all dev only kernels\n        if (BoostConfiguration.enableDevOnlyKernels) {\n            // register the dev only kernels\n            const devKernelTypes: any[] = [BoostQuickBlueprintKernel];\n            kernelTypes = kernelTypes.concat(devKernelTypes);\n        }\n        // constructor and save all kernels\n        for (const kernelType of kernelTypes) {\n            const kernel = new kernelType(\n                context,\n                updateBoostStatusColors.bind(this),\n                this,\n                collection,\n                this.kernels\n            );\n            this.kernels.set(kernel.command, kernel);\n            // ensure all kernels are registered as subscriptions for disposal on exit\n            context.subscriptions.push(kernel);\n        }\n    }\n\n    setupDashboard(context: vscode.ExtensionContext) {\n        const summary = new BoostSummaryViewProvider(context, this);\n        const chat = new BoostChatViewProvider(context, this);\n        const docview = new BoostStartViewProvider(context, this);\n\n        this.summaryViewProvider = summary;\n\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(summaryViewType, summary)\n        );\n\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(\n                BoostChatViewProvider.viewType,\n                chat\n            )\n        );\n\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(\n                BoostStartViewProvider.viewType,\n                docview\n            )\n        );\n\n        /*\n        This is the old tree view code for if/when we go back to that view style\n\n        // Create data providers for each tree\n        const docDataProvider = new BoostTreeDataProvider(this, \"docAnalysis\");\n        const securityDataProvider = new BoostTreeDataProvider(this, \"securityAnalysis\");\n        const complianceDataProvider = new BoostTreeDataProvider(this, \"complianceAnalysis\");\n\n        // Register each TreeDataProvider with vscode\n        vscode.window.registerTreeDataProvider('polyverse-boost-doc-view', docDataProvider);\n        vscode.window.registerTreeDataProvider('polyverse-boost-security-view', securityDataProvider);\n        vscode.window.registerTreeDataProvider('polyverse-boost-compliance-view', complianceDataProvider);  \n        */\n\n        const docs = new BoostMarkdownViewProvider(context, this, \"doc\");\n        const security = new BoostMarkdownViewProvider(\n            context,\n            this,\n            BoostUserAnalysisType.security\n        );\n        const compliance = new BoostMarkdownViewProvider(\n            context,\n            this,\n            BoostUserAnalysisType.compliance\n        );\n        this.blueprintPanel = new BoostMarkdownViewProvider(\n            context,\n            this,\n            BoostUserAnalysisType.blueprint\n        );\n\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(\n                \"polyverse-boost-doc-view\",\n                docs\n            )\n        );\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(\n                \"polyverse-boost-security-view\",\n                security\n            )\n        );\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(\n                \"polyverse-boost-compliance-view\",\n                compliance\n            )\n        );\n        context.subscriptions.push(\n            vscode.window.registerWebviewViewProvider(\n                \"polyverse-boost-blueprint-view\",\n                this.blueprintPanel\n            )\n        );\n    }\n\n    registerCreateNotebookCommand(\n        context: vscode.ExtensionContext,\n        problems: vscode.DiagnosticCollection\n    ) {\n        context.subscriptions.push(\n            vscode.commands.registerCommand(\n                boostnb.NOTEBOOK_TYPE + \".createJsonNotebook\",\n                async () => {\n                    // we prepopulate the notebook with the instructions (as markdown)\n                    const language = \"markdown\";\n                    const defaultInstructionData = instructions.markdown;\n                    const cell = new vscode.NotebookCellData(\n                        vscode.NotebookCellKind.Markup,\n                        defaultInstructionData,\n                        language\n                    );\n                    const data = new vscode.NotebookData([cell]);\n\n                    // get the defaults\n                    const settings = vscode.workspace.getConfiguration(\n                        boostnb.NOTEBOOK_TYPE\n                    );\n\n                    data.metadata = {\n                        outputLanguage: settings.outputLanguage,\n                        testFramework: settings.testFramework,\n                        defaultDir: settings.defaultDir,\n                    };\n\n                    const doc = await vscode.workspace.openNotebookDocument(\n                        boostnb.NOTEBOOK_TYPE,\n                        data\n                    );\n\n                    const editor = await vscode.window.showNotebookDocument(\n                        doc\n                    );\n                }\n            )\n        );\n    }\n\n    registerOpenCodeFile(context: vscode.ExtensionContext) {\n        // Register a command to handle the button click\n        context.subscriptions.push(\n            vscode.commands.registerCommand(\n                boostnb.NOTEBOOK_TYPE + \".loadCodeFile\",\n                async () => {\n                    // Get all the cells in the newly created notebook\n                    const notebookEditor = vscode.window.activeNotebookEditor;\n                    // this should never happen, if it does, we are doing Notebook operations without a Notebook\n                    if (notebookEditor === undefined) {\n                        boostLogging.error(\n                            \"Currently active editor is not a Boost Notebook.\",\n                            true\n                        );\n                        return;\n                    }\n\n                    // see if the user added any data to the cells - since reloading will destroy it\n                    const existingCells = notebookEditor.notebook.getCells();\n                    let userEnteredData = false;\n                    existingCells.forEach((notebookCell) => {\n                        if (\n                            notebookCell.metadata === undefined &&\n                            notebookCell.document.getText().trim() === \"\"\n                        ) {\n                            userEnteredData = true;\n                        }\n                    });\n\n                    if (userEnteredData) {\n                        boostLogging.warn(\n                            \"Existing User-entered data in Cells will be discarded upon loading a new file.\",\n                            true\n                        );\n                    } else if (existingCells.length > 0) {\n                        boostLogging.info(\n                            \"Previously loaded content will be discarded upon loading a new file.\"\n                        );\n                    }\n\n                    // Use the vscode.window.showOpenDialog method to let the user select a file\n                    const fileUri = await vscode.window.showOpenDialog({\n                        canSelectMany: false,\n                        openLabel: \"Load Code File\",\n                        filters: {\n                            // eslint-disable-next-line @typescript-eslint/naming-convention\n                            \"All Files\": [\"*\"],\n                        },\n                    });\n\n                    if (fileUri === undefined || fileUri[0] === undefined) {\n                        return;\n                    } else if (fileUri.length > 1) {\n                        boostLogging.warn(\n                            \"Only one source file can be loaded at a time.\",\n                            true\n                        );\n                    }\n\n                    try {\n                        await parseFunctionsFromFile(\n                            fileUri[0],\n                            notebookEditor.notebook\n                        );\n                    } catch (error) {\n                        boostLogging.error(\n                            `Unable to Boost file:[${fileUri[0].fsPath.toString()} due to error:${error}`,\n                            true\n                        );\n                    }\n                }\n            )\n        );\n    }\n\n    async loadCurrentFolder(uri: vscode.Uri, context: vscode.ExtensionContext) {\n        let targetFolder: vscode.Uri;\n        // if we don't have a folder selected, then the user didn't right click\n        //      so we need to use the workspace folder\n        if (uri === undefined) {\n            if (vscode.workspace.workspaceFolders === undefined) {\n                boostLogging.warn(\n                    \"Unable to find Workspace Folder. Please open a Project or Folder first\"\n                );\n                return;\n            }\n\n            // use first folder in workspace\n            targetFolder = vscode.workspace.workspaceFolders[0].uri;\n            boostLogging.debug(\n                `Analyzing Project Wide source file in Workspace: ${targetFolder.fsPath}`\n            );\n        } else {\n            targetFolder = uri;\n            boostLogging.debug(\n                `Analyzing source files in folder: ${uri.fsPath}`\n            );\n        }\n\n        let baseWorkspace;\n        if (vscode.workspace.workspaceFolders) {\n            baseWorkspace = vscode.workspace.workspaceFolders![0].uri;\n        } else {\n            baseWorkspace = uri;\n        }\n        // we're going to search for everything under our target folder, and let the notebook parsing code filter out what it can't handle\n        let searchPattern = new vscode.RelativePattern(\n            targetFolder.fsPath,\n            \"**/*.*\"\n        );\n        let ignorePattern = await buildVSCodeIgnorePattern();\n        boostLogging.debug(\n            \"Skipping source files of pattern: \" + ignorePattern ?? \"none\"\n        );\n        let files = await vscode.workspace.findFiles(\n            searchPattern,\n            ignorePattern\n                ? new vscode.RelativePattern(targetFolder, ignorePattern)\n                : \"\"\n        );\n\n        boostLogging.debug(\n            \"Analyzing \" + files.length + \" files in folder: \" + targetFolder\n        );\n        try {\n            if (BoostConfiguration.processFoldersInASingleNotebook) {\n                // we're going to create a single notebook for all the files\n                let newNotebook: vscode.NotebookDocument | undefined;\n                for (const file of files) {\n                    newNotebook = (await createOrOpenNotebookFromSourceFile(\n                        file,\n                        false,\n                        true,\n                        newNotebook\n                    )) as vscode.NotebookDocument;\n                    await createOrOpenSummaryNotebookFromSourceFile(file);\n                }\n                // create the folder level rollup\n                await createOrOpenSummaryNotebookFromSourceFile(targetFolder);\n\n                if (newNotebook) {\n                    // we let user know the new scratch notebook was created\n                    boostLogging.warn(\n                        \"Scratch Notebook opened: \" +\n                            newNotebook.uri.toString(),\n                        true\n                    );\n                }\n            } else {\n                let newNotebookWaits: any[] = [];\n\n                files.filter(async (file) => {\n                    newNotebookWaits.push(\n                        createOrOpenNotebookFromSourceFile(file, true)\n                    );\n                    newNotebookWaits.push(\n                        createOrOpenSummaryNotebookFromSourceFile(file)\n                    );\n                });\n                // create project level rollup\n                newNotebookWaits.push(\n                    createOrOpenSummaryNotebookFromSourceFile(targetFolder)\n                );\n\n                await Promise.all(newNotebookWaits)\n                    .then((createdNotebooks) => {\n                        // we are generally creating one new notebook during this process, but in case, we de-dupe it\n                        const newNotebooks = createdNotebooks.filter(\n                            (value, index, self) => {\n                                return self.indexOf(value) === index;\n                            }\n                        );\n                        for (const notebook of newNotebooks) {\n                            // we let user know the new scratch notebook was created\n                            boostLogging.info(\n                                \"Boost Notebook reloaded: \" +\n                                    notebook.fsPath,\n                                false\n                            );\n                        }\n                        boostLogging.info(\n                            `${newNotebookWaits.length.toString()} Boost Notebooks reloaded for folder ${\n                                targetFolder.fsPath\n                            }`,\n                            false\n                        );\n                    })\n                    .catch((error) => {\n                        // Handle the error here\n                        boostLogging.error(\n                            `Error Boosting folder ${targetFolder.fsPath} due to Error: ${error}`\n                        );\n                    });\n            }\n        } catch (error) {\n            boostLogging.error(\n                `Error Boosting folder ${targetFolder} due to Error: ${error}`\n            );\n        }\n    }\n\n    registerFolderRightClickAnalyzeCommand(context: vscode.ExtensionContext) {\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.loadCurrentFolder,\n            async (uri: vscode.Uri) => {\n                return this.loadCurrentFolder(uri, context);\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.processCurrentFolder,\n            async (\n                uri: vscode.Uri,\n                kernelCommand?: string,\n                forceAnalysisRefresh: boolean = false\n            ) => {\n                const likelyViaUI =\n                    !kernelCommand || typeof kernelCommand !== \"string\";\n                if (likelyViaUI) {\n                    kernelCommand = BoostConfiguration.currentKernelCommand;\n                }\n                return this.processCurrentFolder(\n                    uri,\n                    kernelCommand as string,\n                    context,\n                    forceAnalysisRefresh\n                ).catch((error) => {\n                    boostLogging.error((error as Error).message, likelyViaUI);\n                });\n            }\n        );\n        context.subscriptions.push(disposable);\n    }\n\n    registerFolderRightClickOutputCommands(context: vscode.ExtensionContext) {\n        // register the command to build the current file\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.buildCurrentFileOutput,\n            async (uri: vscode.Uri) => {\n                if (!uri) {\n                    boostLogging.error(\n                        `Unable to generate analysis output for current file due to no file selected`,\n                        true\n                    );\n                    return;\n                }\n\n                await this.buildCurrentFileOutput(\n                    uri,\n                    false,\n                    BoostConfiguration.defaultOutputFormat\n                )\n                    .then((outputFile: string) => {\n                        boostLogging.info(\n                            `${outputFile} created`,\n                            uri === undefined\n                        );\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to generate output for current file${\n                                uri.fsPath\n                            } due to ${(error as Error).message}`,\n                            true\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        // register the command to show the current file\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE +\n                \".\" +\n                BoostCommands.showCurrentFileAnalysisOutput,\n            async (uri: vscode.Uri) => {\n                if (!uri) {\n                    boostLogging.error(\n                        `Unable to generate analysis output for current file due to no file selected`,\n                        true\n                    );\n                    return;\n                }\n\n                await this.buildCurrentFileOutput(\n                    uri,\n                    false,\n                    BoostConfiguration.defaultOutputFormat\n                )\n                    .then((outputFile: string) => {\n                        boostLogging.info(\n                            `${outputFile} created for file:${uri.fsPath}.`,\n                            false\n                        );\n\n                        // show the file now\n                        switch (BoostConfiguration.defaultOutputFormat) {\n                            case \"markdown\":\n                                vscode.commands\n                                    .executeCommand(\n                                        \"markdown.showPreview\",\n                                        vscode.Uri.parse(outputFile)\n                                    )\n                                    .then(\n                                        (success) => {\n                                            boostLogging.info(\n                                                `Markdown Preview opened for ${outputFile}`,\n                                                true\n                                            );\n                                        },\n                                        (reason) => {\n                                            boostLogging.error(\n                                                `Unable to open Markdown Preview for ${outputFile} due to ${\n                                                    (reason as Error).message\n                                                }`,\n                                                true\n                                            );\n                                        }\n                                    );\n                                break;\n                            case \"pdf\":\n                            case \"html\":\n                                vscode.env\n                                    .openExternal(vscode.Uri.parse(outputFile))\n                                    .then(\n                                        (success) => {\n                                            boostLogging.info(\n                                                `${BoostConfiguration.defaultOutputFormat.toUpperCase()} Preview opened for ${outputFile}`,\n                                                true\n                                            );\n                                        },\n                                        (reason) => {\n                                            boostLogging.error(\n                                                `Unable to open ${BoostConfiguration.defaultOutputFormat.toUpperCase()} Preview for ${outputFile} due to ${\n                                                    (reason as Error).message\n                                                }`,\n                                                true\n                                            );\n                                        }\n                                    );\n                                break;\n                            default:\n                                boostLogging.error(\n                                    `Unable to open output for ${outputFile} due to unknown format ${BoostConfiguration.defaultOutputFormat}`,\n                                    true\n                                );\n                        }\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to generate and show output for current file ${\n                                uri.fsPath\n                            } due to ${(error as Error).message}`,\n                            true\n                        );\n                    });\n            }\n        );\n\n        context.subscriptions.push(disposable);\n\n        // build analysis output files for all files in the current folder\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE +\n                \".\" +\n                BoostCommands.buildCurrentFolderOutput,\n            async (uri: vscode.Uri) => {\n                return this.buildCurrentFolderOutput(\n                    uri,\n                    BoostConfiguration.defaultOutputFormat\n                ).catch((error: any) => {\n                    boostLogging.error((error as Error).message);\n                });\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        // register the command to build the current file summary\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE +\n                \".\" +\n                BoostCommands.buildCurrentFileSummaryOutput,\n            async (uri: vscode.Uri) => {\n                if (!uri) {\n                    boostLogging.error(\n                        `Unable to generate analysis summary output for current file due to no file selected`,\n                        true\n                    );\n                    return;\n                }\n\n                await this.buildCurrentFileOutput(\n                    uri,\n                    true,\n                    BoostConfiguration.defaultOutputFormat\n                )\n                    .then((outputFile: string) => {\n                        boostLogging.info(\n                            `${outputFile} created for file:${uri.fsPath}.`,\n                            uri === undefined\n                        );\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to generate output for current file${\n                                uri.fsPath\n                            } due to ${(error as Error).message}`,\n                            true\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        // register the command to show the current file as a summary\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE +\n                \".\" +\n                BoostCommands.showCurrentFileAnalysisSummaryOutput,\n            async (uri: vscode.Uri) => {\n                if (!uri) {\n                    boostLogging.error(\n                        `Unable to show analysis summary output for current file due to no file selected`,\n                        true\n                    );\n                    return;\n                }\n\n                await this.buildCurrentFileOutput(\n                    uri,\n                    true,\n                    BoostConfiguration.defaultOutputFormat\n                )\n                    .then((outputFile: string) => {\n                        boostLogging.info(\n                            `${outputFile} created for file:${uri.fsPath}.`,\n                            uri === undefined\n                        );\n\n                        // show the file now\n                        switch (BoostConfiguration.defaultOutputFormat) {\n                            case \"markdown\":\n                                vscode.commands\n                                    .executeCommand(\n                                        \"markdown.showPreview\",\n                                        vscode.Uri.parse(outputFile)\n                                    )\n                                    .then(\n                                        (success) => {\n                                            boostLogging.info(\n                                                `Markdown Preview opened for ${outputFile}`,\n                                                false\n                                            );\n                                        },\n                                        (reason) => {\n                                            boostLogging.error(\n                                                `Unable to open Markdown Preview for ${outputFile} due to ${\n                                                    (reason as Error).message\n                                                }`,\n                                                false\n                                            );\n                                        }\n                                    );\n                                break;\n                            case \"pdf\":\n                            case \"html\":\n                                vscode.env\n                                    .openExternal(vscode.Uri.parse(outputFile))\n                                    .then(\n                                        (success) => {\n                                            boostLogging.info(\n                                                `${BoostConfiguration.defaultOutputFormat.toUpperCase()} Preview opened for ${outputFile}`,\n                                                true\n                                            );\n                                        },\n                                        (reason) => {\n                                            boostLogging.error(\n                                                `Unable to open ${BoostConfiguration.defaultOutputFormat.toUpperCase()} Preview for ${outputFile} due to ${\n                                                    (reason as Error).message\n                                                }`,\n                                                true\n                                            );\n                                        }\n                                    );\n                                break;\n                            default:\n                                boostLogging.error(\n                                    `Unable to open output for ${outputFile} due to unknown format ${BoostConfiguration.defaultOutputFormat}`,\n                                    true\n                                );\n                        }\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to generate and show summary output for current file${\n                                uri.fsPath\n                            } due to ${(error as Error).message}`,\n                            true\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        // register the command to build the current folder summary\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE +\n                \".\" +\n                BoostCommands.buildCurrentFolderSummaryOutput,\n            async (uri: vscode.Uri) => {\n                await this.buildCurrentFileOutput(\n                    uri,\n                    true,\n                    BoostConfiguration.defaultOutputFormat\n                )\n                    .then((outputFile: string) => {\n                        if (!uri) {\n                            boostLogging.info(\n                                `${outputFile} created`,\n                                uri === undefined\n                            );\n                        } else {\n                            boostLogging.info(\n                                `${outputFile} created for file:${uri.fsPath}.`,\n                                uri === undefined\n                            );\n                        }\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to generate summary output for current folder${\n                                uri ? \":\" + uri.fsPath : \"\"\n                            } due to ${(error as Error).message}`,\n                            uri === undefined\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        // register the command to show the current folder summary\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE +\n                \".\" +\n                BoostCommands.showCurrentFolderAnalysisSummaryOutput,\n            async (uri: vscode.Uri) => {\n                await this.buildCurrentFileOutput(\n                    uri,\n                    true,\n                    BoostConfiguration.defaultOutputFormat\n                )\n                    .then((outputFile: string) => {\n                        if (!uri) {\n                            boostLogging.info(`${outputFile} created`, false);\n                        } else {\n                            boostLogging.info(\n                                `${outputFile} created for file:${uri.fsPath}.`,\n                                uri === undefined\n                            );\n                        }\n\n                        // show the file now\n                        switch (BoostConfiguration.defaultOutputFormat) {\n                            case \"markdown\":\n                                vscode.commands\n                                    .executeCommand(\n                                        \"markdown.showPreview\",\n                                        vscode.Uri.parse(outputFile)\n                                    )\n                                    .then(\n                                        (success) => {\n                                            boostLogging.info(\n                                                `Markdown Preview opened for ${outputFile}`,\n                                                false\n                                            );\n                                        },\n                                        (reason) => {\n                                            boostLogging.error(\n                                                `Unable to open Markdown Preview for ${outputFile} due to ${\n                                                    (reason as Error).message\n                                                }`,\n                                                true\n                                            );\n                                        }\n                                    );\n                                break;\n                            case \"pdf\":\n                            case \"html\":\n                                vscode.env\n                                    .openExternal(vscode.Uri.parse(outputFile))\n                                    .then(\n                                        (success) => {\n                                            boostLogging.info(\n                                                `${BoostConfiguration.defaultOutputFormat.toUpperCase()} Preview opened for ${outputFile}`,\n                                                true\n                                            );\n                                        },\n                                        (reason) => {\n                                            boostLogging.error(\n                                                `Unable to open ${BoostConfiguration.defaultOutputFormat.toUpperCase()} Preview for ${outputFile} due to ${\n                                                    (reason as Error).message\n                                                }`,\n                                                true\n                                            );\n                                        }\n                                    );\n                                break;\n                            default:\n                                boostLogging.error(\n                                    `Unable to open output for ${outputFile} due to unknown format ${BoostConfiguration.defaultOutputFormat}`,\n                                    true\n                                );\n                        }\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to generate and show summary output for current folder${\n                                uri ? \":\" + uri.fsPath : \"\"\n                            } due to ${(error as Error).message}`,\n                            true\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n    }\n\n    registerRefreshProjectDataCommands(context: vscode.ExtensionContext) {\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.refreshProjectData,\n            async () => {\n                await this.refreshBoostProjectsData()\n                    .then(() => {\n                        boostLogging.info(\n                            `Refreshed Boost Project Data.`,\n                            false\n                        );\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to Refresh Project Data due to error ${(error as Error).message}`,\n                            false\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n    }\n\n    registerSourceCodeRightClickCommands(context: vscode.ExtensionContext) {\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.analyzeSourceCode,\n            async () => {\n                const editor = vscode.window.activeTextEditor;\n\n                if (!editor) {\n                    boostLogging.warn(\n                        `No active editor found to analyze source code.`,\n                        false\n                    );\n                    return;\n                }\n\n                // get the user's selected text\n                const selectedText = editor.document.getText(editor.selection);\n                if (selectedText === undefined || selectedText === \"\") {\n                    boostLogging.warn(\n                        `No text selected to analyze source code.`,\n                        true\n                    );\n                    return;\n                }\n\n                const targetedKernel = this.getCurrentKernel(\n                    BoostConfiguration.currentKernelCommand\n                );\n                if (targetedKernel === undefined) {\n                    boostLogging.warn(\n                        `Please select an Analysis command type via Boost Status Bar at bottom of screen`,\n                        true\n                    );\n                    return;\n                }\n\n                // analyze the source code\n                await this.analyzeSourceCode(selectedText)\n                    .then((analysisResults: string) => {\n                        boostLogging.info(analysisResults, true);\n                    })\n                    .catch((error: any) => {\n                        boostLogging.error(\n                            `Unable to Analyze Selected Text with ${\n                                BoostConfiguration.currentKernelCommand\n                            } due to ${error as Error}`,\n                            true\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n    }\n\n    registerShowGuidelinesCommand(context: vscode.ExtensionContext) {\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.showGuidelines,\n            async (guidelineType) => {\n                const globalProjectGuidelineFile = getBoostFile(\n                    undefined,\n                    BoostFileType.guidelines,\n                    false\n                );\n                let projectGuidelineFile;\n                if (!guidelineType) {\n                    projectGuidelineFile = globalProjectGuidelineFile;\n                } else {\n                    if (!(guidelineType in BoostUserAnalysisType)) {\n                        guidelineType = this.getUserAnalysisType(guidelineType);\n                    }\n                    // this user guideline file\n                    const userGuidelinesFile =\n                        globalProjectGuidelineFile.fsPath.replace(\n                            boostnb.NOTEBOOK_GUIDELINES_PRE_EXTENSION,\n                            `.${guidelineType}${boostnb.NOTEBOOK_GUIDELINES_PRE_EXTENSION}`\n                        );\n                    projectGuidelineFile = vscode.Uri.file(userGuidelinesFile);\n                }\n\n                if (getOrCreateGuideline(projectGuidelineFile, guidelineType)) {\n                    boostLogging.info(\n                        `No guidelines found for project. Building ${projectGuidelineFile.fsPath}`,\n                        false\n                    );\n                }\n\n                const guidelinesNotebook =\n                    await vscode.workspace.openNotebookDocument(\n                        projectGuidelineFile\n                    );\n                vscode.window.showNotebookDocument(guidelinesNotebook);\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        for (let guidelineTypeKey in BoostUserAnalysisType) {\n            if (\n                Object.prototype.hasOwnProperty.call(\n                    BoostUserAnalysisType,\n                    guidelineTypeKey\n                )\n            ) {\n                let guidelineType =\n                    BoostUserAnalysisType[\n                        guidelineTypeKey as keyof typeof BoostUserAnalysisType\n                    ];\n\n                let disposable = vscode.commands.registerCommand(\n                    `${boostnb.NOTEBOOK_TYPE}.${BoostCommands.showGuidelines}.${guidelineType}`,\n                    async () => {\n                        await vscode.commands.executeCommand(\n                            `${boostnb.NOTEBOOK_TYPE}.${BoostCommands.showGuidelines}`,\n                            guidelineType\n                        );\n                    }\n                );\n            }\n            context.subscriptions.push(disposable);\n        }\n    }\n\n    async analyzeSourceCode(selectedText: string): Promise<string> {\n        return new Promise(async (resolve, reject) => {\n            try {\n                if (selectedText === undefined || selectedText === \"\") {\n                    reject(\n                        new Error(\"No text selected to analyze source code.\")\n                    );\n                    return;\n                }\n\n                // use default selected kernel\n                const targetedKernel = this.getCurrentKernel(\n                    BoostConfiguration.currentKernelCommand\n                );\n                if (targetedKernel === undefined) {\n                    reject(\n                        new Error(\n                            `Unable to match analysis kernel to analyze source code.`\n                        )\n                    );\n                    return;\n                }\n\n                let notebook = new boostnb.BoostNotebook();\n                notebook.addCell(\n                    new boostnb.BoostNotebookCell(\n                        boostnb.NotebookCellKind.Code,\n                        selectedText,\n                        \"plaintext\",\n                        undefined\n                    )\n                );\n                const cellMetadata = {\n                    model: \"gpt-3.5-turbo\",\n                    temperature: 0.1,\n                }; // fast-processing model\n                notebook.cells[0].initializeMetadata(cellMetadata);\n\n                vscode.commands.executeCommand(\n                    `workbench.view.extension.${boostActivityBarId}`\n                );\n\n                targetedKernel\n                    .executeAllWithAuthorization(notebook.cells, notebook)\n                    .then(() => {\n                        resolve(\n                            cleanCellOutput(\n                                notebook.cells[0].outputs[0].items[0].data\n                            )\n                        );\n                    })\n                    .catch((error) => {\n                        reject(error);\n                    });\n            } catch (error) {\n                reject(error as Error);\n            }\n        });\n    }\n\n    async loadCurrentFile(\n        sourceFileUri: vscode.Uri,\n        context: vscode.ExtensionContext\n    ): Promise<boolean> {\n        return new Promise(async (resolve, reject) => {\n            try {\n                // if we don't have a file selected, then the user didn't right click\n                //      so we need to find the current active editor, if its available\n                if (sourceFileUri === undefined) {\n                    if (vscode.window.activeTextEditor === undefined) {\n                        boostLogging.warn(\n                            \"Unable to identify an active file to Boost.\",\n                            true\n                        );\n                        resolve(false);\n                    } else {\n                        sourceFileUri =\n                            vscode.window.activeTextEditor?.document.uri;\n\n                        if (!fs.existsSync(sourceFileUri.fsPath)) {\n                            boostLogging.warn(\n                                `Unable to find file ${sourceFileUri.fsPath} to Boost. It may not be saved to disk yet.`,\n                                false\n                            );\n                        }\n                    }\n                }\n\n                let currentNotebook =\n                    vscode.window.activeNotebookEditor?.notebook;\n                if (\n                    currentNotebook &&\n                    sourceFileUri &&\n                    currentNotebook.uri.fsPath !== sourceFileUri.fsPath\n                ) {\n                    // if the open notebook doesn't match, don't use it\n                    currentNotebook = undefined;\n                }\n\n                // if there is no active notebook editor, we need to find it\n                // Note this only happens when using right-click in explorer or a non-Notebook active editor\n                if (currentNotebook === undefined && !sourceFileUri) {\n                    const boostNotebooks: vscode.NotebookDocument[] =\n                        vscode.workspace.notebookDocuments.filter(\n                            async (doc) => {\n                                // we're skipping non Boost notebooks\n                                resolve(\n                                    doc.notebookType === boostnb.NOTEBOOK_TYPE\n                                );\n                                return;\n                            }\n                        );\n\n                    // if we have more than one notebook, we need to ask user which one to use\n                    if (boostNotebooks.length > 1) {\n                        let notebookNames = boostNotebooks.map((doc) => {\n                            return path.basename(\n                                vscode.Uri.parse(doc.uri.toString()).fsPath\n                            );\n                        });\n\n                        // show the user a list of available notebooks\n                        const selectedOption =\n                            await vscode.window.showQuickPick(notebookNames, {\n                                canPickMany: false,\n                                placeHolder: \"Select a Boost Notebook to use\",\n                            });\n                        // if user doesn't pick anything, then just give up\n                        if (!selectedOption) {\n                            resolve(false);\n                            return;\n                        }\n                        // otherwise find the notebook that matches the user's selection\n                        currentNotebook = boostNotebooks.find((doc) => {\n                            return (\n                                path.basename(\n                                    vscode.Uri.parse(doc.uri.toString()).fsPath\n                                ) === selectedOption\n                            );\n                        });\n                    } else if (boostNotebooks.length === 1) {\n                        // if we only have one notebook (that matches Uri), then just use that one\n                        currentNotebook = boostNotebooks[0];\n                    }\n                }\n\n                // if we still failed to find an available Notebook, then warn and give up\n                if (currentNotebook === undefined) {\n                    if (\n                        !sourceFileUri.fsPath.endsWith(\n                            boostnb.NOTEBOOK_SUMMARY_EXTENSION\n                        )\n                    ) {\n                        currentNotebook =\n                            (await createOrOpenNotebookFromSourceFile(\n                                sourceFileUri,\n                                false,\n                                true\n                            )) as vscode.NotebookDocument;\n                        await createOrOpenSummaryNotebookFromSourceFile(\n                            sourceFileUri\n                        );\n                    } else {\n                        // look up summary for raw source file by stripping off notebook extension\n                        const summaryBoostFile = vscode.Uri.parse(\n                            sourceFileUri.fsPath\n                                .replace(boostnb.NOTEBOOK_SUMMARY_EXTENSION, \"\")\n                                .replace(\n                                    \"/\" + BoostConfiguration.defaultDir,\n                                    \"\"\n                                )\n                        );\n                        await createOrOpenSummaryNotebookFromSourceFile(\n                            summaryBoostFile\n                        );\n                        currentNotebook =\n                            await vscode.workspace.openNotebookDocument(\n                                sourceFileUri\n                            );\n                    }\n                    boostLogging.warn(\n                        `No active Notebook found. Created default Notebook for: ${sourceFileUri.toString()}`\n                    );\n                } else if (\n                    !sourceFileUri.fsPath.endsWith(boostnb.NOTEBOOK_EXTENSION)\n                ) {\n                    await parseFunctionsFromFile(\n                        sourceFileUri,\n                        currentNotebook\n                    );\n                }\n\n                boostLogging.log(\n                    `Loaded Boost file:[${sourceFileUri.fsPath.toString()}`\n                );\n                vscode.window.showNotebookDocument(currentNotebook);\n            } catch (error) {\n                boostLogging.error(\n                    `Unable to load Boost file:[${sourceFileUri.fsPath.toString()} due to error:${error}`,\n                    false\n                );\n                resolve(false);\n                return;\n            }\n            resolve(true);\n        });\n    }\n\n    async processCurrentFile(\n        sourceUri: vscode.Uri,\n        kernelCommand: string,\n        _: vscode.ExtensionContext,\n        forceAnalysisRefresh: boolean = false\n    ): Promise<boostnb.BoostNotebook> {\n        return new Promise(async (resolve, reject) => {\n            try {\n                let inMemorySourceFile = false; // the source file is in memory (either Notebook or raw source)\n\n                // if we don't have a file selected, then the user didn't right click\n                // so we need to find the current active editor if it's available\n                if (sourceUri === undefined) {\n                    if (vscode.window.activeTextEditor === undefined) {\n                        boostLogging.warn(\n                            `Unable to identify an active file to Process ${kernelCommand}`,\n                            true\n                        );\n                        reject(\n                            new Error(\n                                `Unable to identify an active file to Process ${kernelCommand}`\n                            )\n                        );\n                        return;\n                    } else {\n                        sourceUri =\n                            vscode.window.activeTextEditor?.document.uri;\n                        if (!fs.existsSync(sourceUri.fsPath)) {\n                            inMemorySourceFile = true;\n                            boostLogging.error(\n                                `Canceling in-memory source file processing ${sourceUri.toString()}`,\n                                false\n                            );\n                            reject(\n                                new Error(\n                                    `Please save ${sourceUri.toString()} before processing`\n                                )\n                            );\n                            return;\n                        } else if (\n                            vscode.window.activeTextEditor?.document.isDirty\n                        ) {\n                            boostLogging.warn(\n                                `File ${sourceUri.toString()} has unsaved changes.`,\n                                true\n                            );\n                        }\n                    }\n                }\n\n                const targetedKernel = this.getCurrentKernel(kernelCommand);\n                if (targetedKernel === undefined) {\n                    boostLogging.warn(\n                        `Unable to match analysis kernel for ${kernelCommand}`,\n                        false\n                    );\n                    reject(\n                        new Error(\n                            `Unable to match analysis kernel for ${kernelCommand}`\n                        )\n                    );\n                    return;\n                }\n\n                let notebookUri = sourceUri;\n                // if we got a source file or folder, then load the notebook from it\n                if (!sourceUri.fsPath.endsWith(boostnb.NOTEBOOK_EXTENSION)) {\n                    if (targetedKernel.command === summarizeKernelName) {\n                        notebookUri = getBoostFile(\n                            sourceUri,\n                            BoostFileType.notebook\n                        );\n                    } else {\n                        notebookUri = getBoostFile(\n                            sourceUri,\n                            BoostFileType.notebook\n                        );\n                    }\n                } // else we are using a notebook file, so just use it\n\n                let notebook = new boostnb.BoostNotebook();\n                if (!fs.existsSync(notebookUri.fsPath)) {\n                    if (targetedKernel.command !== summarizeKernelName) {\n                        // if we haven't yet loaded/parsed this file, then let's do it implicitly for the customer\n                        await createOrOpenNotebookFromSourceFile(\n                            sourceUri,\n                            true\n                        );\n                        await createOrOpenSummaryNotebookFromSourceFile(\n                            sourceUri\n                        );\n\n                        notebook.load(notebookUri.fsPath);\n                    } else {\n                        // if we are summarizing, then we need to create the summary notebook\n                        notebook =\n                            await createOrOpenSummaryNotebookFromSourceFile(\n                                sourceUri\n                            );\n                    }\n                } else {\n                    notebook.load(notebookUri.fsPath);\n                }\n                targetedKernel\n                    .executeAllWithAuthorization(\n                        notebook.cells,\n                        notebook,\n                        forceAnalysisRefresh\n                    )\n                    .then(() => {\n                        if (targetedKernel.command === summarizeKernelName) {\n                            const summaryNotebookUri = getBoostFile(\n                                sourceUri,\n                                BoostFileType.summary\n                            );\n                            boostLogging.info(\n                                `Saved Updated Notebook for ${kernelCommand} in file:[${summaryNotebookUri.fsPath}]`,\n                                false\n                            );\n                        } else {\n                            // ensure we save the notebook if we successfully processed it\n                            notebook.save(notebookUri.fsPath);\n                            boostLogging.info(\n                                `Saved Updated Notebook for ${kernelCommand} in file:[${notebookUri.fsPath}]`,\n                                false\n                            );\n                        }\n                        resolve(notebook);\n                    })\n                    .catch((error) => {\n                        boostLogging.warn(\n                            `Skipping Notebook save - due to Error Processing ${kernelCommand} on file:[${sourceUri.fsPath}] due to error:${error}`,\n                            true\n                        );\n                        reject(error);\n                    });\n            } catch (error) {\n                reject(error as Error);\n            }\n        });\n    }\n\n    public getUserAnalysisType(kernelName: string): string {\n        switch (kernelName) {\n            case analyzeKernelName:\n            case analyzeFunctionKernelName:\n                return BoostUserAnalysisType.security;\n            case complianceKernelName:\n            case complianceFunctionKernelName:\n                return BoostUserAnalysisType.compliance;\n            case flowDiagramKernelName:\n            case explainKernelName:\n                return BoostUserAnalysisType.documentation;\n            case blueprintKernelName:\n            case summarizeKernelName:\n            case codeGuidelinesKernelName:\n            case convertKernelName:\n            case testgenKernelName:\n            case performanceKernelName:\n            case performanceFunctionKernelName:\n            case customProcessCellMarker:\n                return BoostUserAnalysisType.blueprint;\n            default:\n                return kernelName;\n        }\n    }\n\n    private getCurrentKernel(\n        requestedKernel?: string\n    ): KernelControllerBase | undefined {\n        if (!requestedKernel && !this.kernelCommand) {\n            boostLogging.error(`No Boost Kernel Command selected`, false);\n            return undefined;\n        } else if (!requestedKernel) {\n            requestedKernel = this.kernelCommand;\n        }\n\n        let targetedKernel: KernelControllerBase | undefined;\n        this.kernels.forEach((kernel) => {\n            if (kernel.id === requestedKernel) {\n                targetedKernel = kernel;\n            }\n        });\n        if (targetedKernel === undefined) {\n            boostLogging.error(\n                `Unable to find Kernel for ${requestedKernel}`,\n                false\n            );\n            return undefined;\n        }\n        return targetedKernel;\n    }\n\n    private calculateEstimatedWords(fileSize: number): number {\n        // Custom logic to estimate the number of words based on file size\n        // Adjust this calculation based on the characteristics of your files\n        const averageWordsPerByte = 0.05; // Example value\n        return Math.floor(fileSize * averageWordsPerByte);\n    }\n\n    private calculateProcessingTime(\n        estimatedWords: number,\n        wordsPerFile: number\n    ): number {\n        const oneMinute = 60 * 1000;\n        const processingMinutes = estimatedWords / wordsPerFile;\n        const processingMilliseconds = processingMinutes * oneMinute;\n        return processingMilliseconds;\n    }\n\n    private delay(ms: number): Promise<void> {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n\n    async processCurrentFolder(\n        uri: vscode.Uri,\n        kernelCommand: string,\n        context: vscode.ExtensionContext,\n        forceAnalysisRefresh: boolean = false\n    ) {\n        let targetFolder: vscode.Uri;\n        // if we don't have a folder selected, then the user didn't right click\n        // so we need to use the workspace folder\n        if (uri === undefined) {\n            if (vscode.workspace.workspaceFolders === undefined) {\n                boostLogging.warn(\n                    \"Unable to find Workspace Folder. Please open a Project or Folder first\",\n                    true\n                );\n                return;\n            }\n\n            // use the first folder in the workspace\n            targetFolder = vscode.workspace.workspaceFolders[0].uri;\n            boostLogging.debug(\n                `Analyzing Project Wide source file in Workspace: ${targetFolder.fsPath}`\n            );\n        } else {\n            targetFolder = uri;\n            boostLogging.debug(\n                `Analyzing source files in folder: ${uri.fsPath}`\n            );\n        }\n\n        let baseWorkspace;\n        if (vscode.workspace.workspaceFolders) {\n            baseWorkspace = vscode.workspace.workspaceFolders![0].uri;\n        } else {\n            baseWorkspace = uri;\n        }\n        // we're going to search for everything under our target folder, and let the notebook parsing code filter out what it can't handle\n        let searchPattern = new vscode.RelativePattern(\n            targetFolder.fsPath,\n            \"**/*.*\"\n        );\n        let ignorePattern = await buildVSCodeIgnorePattern();\n        boostLogging.debug(\n            \"Skipping source files of pattern: \" + (ignorePattern ?? \"none\")\n        );\n        let files = await vscode.workspace.findFiles(\n            searchPattern,\n            ignorePattern\n                ? new vscode.RelativePattern(targetFolder, ignorePattern)\n                : \"\"\n        );\n\n        boostLogging.debug(\n            \"Analyzing \" + files.length + \" files in folder: \" + targetFolder\n        );\n\n        const targetedKernel = this.getCurrentKernel(kernelCommand);\n        if (targetedKernel === undefined) {\n            return;\n        }\n\n        const boostprojectdata = await this.getBoostProjectData();\n\n        try {\n            await preflightCheckForCustomerStatus(context, this);\n        } catch (error) {\n            const folderName = path.basename(targetFolder.fsPath);\n            boostLogging.error(\n                `Unable to process folder ${folderName} due to error: ${error}`\n            );\n            return;\n        }\n        try {\n            // estimated processing about 160 pages of code per minute\n            // Using the same calculation as before, at a rate of 40,000 words per minute (666.67 words per second) and\n            //  assuming an average of 250 words per page:\n            //      Pages processed = (Words processed / Words per page) = (666.67 words per second * 60 seconds) / 250 words per page\n            //      Pages processed = 160 pages\n\n            const throttleRateTokensPerMinute = 40000; // Approximated as words per minute\n            const totalFiles = files.length;\n            const wordsPerFile = throttleRateTokensPerMinute / totalFiles;\n            const seconds = 1000;\n\n            let processedNotebookWaits: Promise<boostnb.BoostNotebook>[] =\n                files.map(async (file) => {\n                    return new Promise<boostnb.BoostNotebook>(\n                        (resolve, reject) => {\n                            const fileSize = fs.statSync(file.fsPath).size;\n                            const estimatedWords =\n                                this.calculateEstimatedWords(fileSize);\n                            const processingTime = this.calculateProcessingTime(\n                                estimatedWords,\n                                wordsPerFile\n                            );\n\n                            boostLogging.log(\n                                `Delaying file ${\n                                    file.fsPath\n                                } with ${estimatedWords} ~items to wait ${\n                                    processingTime / seconds\n                                } secs`\n                            );\n                            // get the distance from the workspace folder for the source file\n                            // for project-level status files, we ignore the relative path\n                            let relativePath = path.relative(\n                                targetFolder.fsPath,\n                                file.fsPath\n                            );\n                            this.summaryViewProvider?.addQueue(\n                                targetedKernel.outputType,\n                                [relativePath],\n                                boostprojectdata\n                            );\n                            setTimeout(async () => {\n                                // if its been more than 5 seconds, log it - that's about 13 pages of source in 5 seconds (wild estimate)\n                                if (processingTime > 5 * seconds) {\n                                    boostLogging.log(\n                                        `Starting processing file ${\n                                            file.fsPath\n                                        } with ${estimatedWords} ~items after waiting ${\n                                            processingTime * seconds\n                                        } secs`\n                                    );\n                                }\n\n                                this.summaryViewProvider?.addJobs(\n                                    targetedKernel.outputType,\n                                    [relativePath],\n                                    boostprojectdata\n                                );\n\n                                this.processCurrentFile(\n                                    file,\n                                    targetedKernel.id,\n                                    context,\n                                    forceAnalysisRefresh\n                                )\n                                    .then((notebook) => {\n                                        let summary =\n                                            boostNotebookToFileSummaryItem(\n                                                notebook\n                                            );\n                                        const boostprojectdata =\n                                            this.getBoostProjectData();\n                                        this.summaryViewProvider?.finishJob(\n                                            targetedKernel.outputType,\n                                            relativePath,\n                                            summary,\n                                            boostprojectdata,\n                                            null\n                                        );\n                                        resolve(notebook);\n                                    })\n                                    .catch((error) => {\n                                        // get the distance from the workspace folder for the source file\n                                        // for project-level status files, we ignore the relative path\n                                        let relativePath = path.relative(\n                                            targetFolder.fsPath,\n                                            file.fsPath\n                                        );\n                                        const boostprojectdata =\n                                            this.getBoostProjectData();\n                                        this.summaryViewProvider?.finishJob(\n                                            targetedKernel.outputType,\n                                            relativePath,\n                                            null,\n                                            boostprojectdata,\n                                            error\n                                        );\n                                        reject(error);\n                                    });\n                            }, processingTime);\n                        }\n                    );\n                });\n\n            await Promise.all(processedNotebookWaits)\n                .then((processedNotebooks) => {\n                    processedNotebooks.forEach((notebook) => {\n                        // we let the user know the notebook was processed\n                        boostLogging.info(\n                            `Boost Notebook processed with command ${targetedKernel.command}: ${notebook.fsPath}`,\n                            false\n                        );\n                    });\n                    boostLogging.info(\n                        `${processedNotebookWaits.length.toString()} Boost Notebooks processed for folder ${\n                            targetFolder.fsPath\n                        }`,\n                        false\n                    );\n                })\n                .catch((error) => {\n                    // Handle the error here\n                    boostLogging.error(\n                        `Error Boosting folder ${targetFolder.fsPath} due to Error: ${error}`,\n                        false\n                    );\n                });\n\n            // if we are doing a summary operation, then we process the named folder only (for the project/folder-level summary)\n            // this happens after we do rollup summaries for all other source files - to make our project-level use the latest rollup\n            if (targetedKernel.command === summarizeKernelName) {\n                boostLogging.debug(\n                    `Boost Project-level Summary starting with Project: ${targetFolder.fsPath}`\n                );\n                await this.processCurrentFile(\n                    targetFolder,\n                    targetedKernel.id,\n                    context,\n                    forceAnalysisRefresh\n                );\n                boostLogging.info(\n                    `Boost Project-level Summary completed with Project: ${targetFolder.fsPath}`,\n                    false\n                );\n            }\n        } catch (error) {\n            boostLogging.error(\n                `Unable to Process ${kernelCommand} on Folder:[${uri.fsPath.toString()} due to error:${error}`,\n                false\n            );\n        }\n    }\n\n    registerProjectLevelCommands(context: vscode.ExtensionContext) {\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.processProject,\n            async (kernelCommand?: string) => {\n                // we only process project level analysis at summary level for now\n                const projectBoostFile = getBoostFile(\n                    undefined,\n                    BoostFileType.summary,\n                    false\n                );\n                // create the Boost file, if it doesn't exist\n                if (!fs.existsSync(projectBoostFile.fsPath)) {\n                    boostLogging.warn(\n                        `Unable to open Project-level Boost Notebook [${projectBoostFile.fsPath}]; check the Polyverse Boost Output channel for details`\n                    );\n                    return;\n                }\n\n                const likelyViaUI =\n                    !kernelCommand || typeof kernelCommand !== \"string\";\n                if (likelyViaUI) {\n                    kernelCommand = BoostConfiguration.currentKernelCommand;\n                }\n\n                const targetedKernel = this.getCurrentKernel(kernelCommand);\n                if (targetedKernel === undefined) {\n                    boostLogging.warn(\n                        `Unable to match analysis kernel for ${kernelCommand}`,\n                        likelyViaUI\n                    );\n                    return;\n                }\n\n                if (targetedKernel.command !== quickBlueprintKernelName) {\n                    boostLogging.error(\n                        \"Currently, only Quick Blueprint is supported at Project-level\",\n                        likelyViaUI\n                    );\n                    return;\n                }\n\n                let notebook = new boostnb.BoostNotebook();\n                notebook.load(projectBoostFile.fsPath);\n                targetedKernel\n                    .executeAllWithAuthorization(notebook.cells, notebook, true)\n                    .then(() => {\n                        // ensure we save the notebook if we successfully processed it\n                        notebook.flushToFS();\n                        // TODO, this should be more general once we have more than one project level command\n                        this.blueprintPanel?.refresh();\n\n                        boostLogging.info(\n                            `Saved Updated Notebook for ${kernelCommand} in file:[${projectBoostFile.fsPath}]`,\n                            likelyViaUI\n                        );\n                    })\n                    .catch((error) => {\n                        boostLogging.warn(\n                            `Skipping Notebook save - due to Error Processing ${kernelCommand} on file:[${projectBoostFile.fsPath}] due to error:${error}`,\n                            likelyViaUI\n                        );\n                    });\n            }\n        );\n        context.subscriptions.push(disposable);\n    }\n\n    registerFileRightClickAnalyzeCommand(context: vscode.ExtensionContext) {\n        let disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.loadCurrentFile,\n            async (uri: vscode.Uri) => {\n                const boostFile = getBoostFile(uri);\n                // create the Boost file, if it doesn't exist\n                if (!fs.existsSync(boostFile.fsPath)) {\n                    if (\n                        !(await this.loadCurrentFile(uri, context)) ||\n                        !fs.existsSync(boostFile.fsPath)\n                    ) {\n                        boostLogging.warn(\n                            `Unable to open Boost Notebook for file:[${uri.fsPath}]; check the Polyverse Boost Output channel for details`\n                        );\n                        return;\n                    }\n                }\n                const boostDoc = await vscode.workspace.openNotebookDocument(\n                    boostFile\n                );\n                vscode.window.showNotebookDocument(boostDoc);\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.processCurrentFile,\n            async (\n                uri: vscode.Uri,\n                kernelCommand?: string,\n                forceAnalysisRefresh: boolean = false\n            ) => {\n                const likelyViaUI =\n                    !kernelCommand || typeof kernelCommand !== \"string\";\n                if (likelyViaUI) {\n                    kernelCommand = BoostConfiguration.currentKernelCommand;\n                }\n                return this.processCurrentFile(\n                    uri,\n                    kernelCommand as string,\n                    context,\n                    forceAnalysisRefresh\n                ).catch((error) => {\n                    boostLogging.error((error as Error).message, likelyViaUI);\n                });\n            }\n        );\n        context.subscriptions.push(disposable);\n\n        disposable = vscode.commands.registerCommand(\n            boostnb.NOTEBOOK_TYPE + \".\" + BoostCommands.loadSummaryFile,\n            async (uri: vscode.Uri) => {\n                const boostFile = getBoostFile(uri, BoostFileType.summary);\n                // create the Boost file, if it doesn't exist\n                if (!fs.existsSync(boostFile.fsPath)) {\n                    if (\n                        !(await this.loadCurrentFile(boostFile, context)) ||\n                        !fs.existsSync(boostFile.fsPath)\n                    ) {\n                        boostLogging.warn(\n                            `Unable to open Boost Summary Notebook for file:[${uri.fsPath}]; check the Polyverse Boost Output channel for details`,\n                            true\n                        );\n                        return;\n                    }\n                }\n                const boostDoc = await vscode.workspace.openNotebookDocument(\n                    boostFile\n                );\n                vscode.window.showNotebookDocument(boostDoc);\n            }\n        );\n        context.subscriptions.push(disposable);\n    }\n\n    async buildCurrentFileOutput(\n        uri: vscode.Uri,\n        summary: boolean,\n        outputFormat: string\n    ): Promise<string> {\n        return new Promise<string>((resolve, reject) => {\n            try {\n                // if we don't have a file selected, and asking for single file analysis, then fail\n                //  we only report summaries for folders\n                if (uri === undefined) {\n                    if (!summary) {\n                        boostLogging.warn(\n                            `Unable to identify an active file to process ${this.kernelCommand}`\n                        );\n                        reject(new Error(\"No active file found\"));\n                        return;\n                    } else if (!vscode.workspace.workspaceFolders) {\n                        boostLogging.error(\n                            `Cannot build summary without a Workspace or Project loaded`\n                        );\n                        reject(\n                            new Error(\n                                \"Cannot build summary without a Workspace or Project loaded\"\n                            )\n                        );\n                        return;\n                    }\n\n                    uri = vscode.workspace.workspaceFolders[0].uri;\n                }\n\n                let boostUri = uri;\n                // if we got a source file, then load the notebook from it\n                if (!uri.fsPath.endsWith(boostnb.NOTEBOOK_EXTENSION)) {\n                    if (summary) {\n                        boostUri = getBoostFile(uri, BoostFileType.summary);\n                    } else {\n                        boostUri = getBoostFile(uri);\n                    }\n                }\n\n                if (!fs.existsSync(boostUri.fsPath)) {\n                    reject(\n                        new Error(\n                            `Unable to find Boost notebook for ${uri.fsPath} - please create Boost notebook first`\n                        )\n                    );\n                    return;\n                }\n\n                const baseWorkspacePath =\n                    vscode.workspace.workspaceFolders![0].uri.fsPath;\n\n                // if user didn't specify output format, then we'll use configuration\n                if (!outputFormat) {\n                    outputFormat = BoostConfiguration.defaultOutputFormat;\n                }\n                switch (outputFormat.toLowerCase()) {\n                    case \"html\":\n                        generateHTMLforNotebook(\n                            boostUri.fsPath,\n                            baseWorkspacePath\n                        )\n                            .then((htmlFile) => {\n                                resolve(htmlFile);\n                            })\n                            .catch((error) => {\n                                reject(error);\n                            });\n                        break;\n                    case \"pdf\":\n                        generatePDFforNotebook(\n                            boostUri.fsPath,\n                            baseWorkspacePath\n                        )\n                            .then((pdfFile) => {\n                                resolve(pdfFile);\n                            })\n                            .catch((error) => {\n                                reject(error);\n                            });\n                        break;\n                    case \"markdown\":\n                        generateMarkdownforNotebook(\n                            boostUri.fsPath,\n                            baseWorkspacePath\n                        )\n                            .then((markdownFile) => {\n                                resolve(markdownFile);\n                            })\n                            .catch((error) => {\n                                reject(error);\n                            });\n                        break;\n                    default:\n                        reject(\n                            new Error(\n                                `Unsupported output format ${outputFormat} - please use html, pdf, or markdown`\n                            )\n                        );\n                }\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    async buildCurrentFolderOutput(\n        folderUri: vscode.Uri,\n        outputFormat: string\n    ) {\n        let targetFolder: vscode.Uri;\n        // if we don't have a folder selected, then the user didn't right click\n        //      so we need to use the workspace folder\n        if (folderUri === undefined) {\n            if (vscode.workspace.workspaceFolders === undefined) {\n                boostLogging.warn(\n                    \"Unable to find Workspace Folder. Please open a Project or Folder first\"\n                );\n                return;\n            }\n\n            // use first folder in workspace\n            targetFolder = vscode.workspace.workspaceFolders[0].uri;\n            boostLogging.debug(\n                `Analyzing Project Wide Boost files in Workspace: ${targetFolder.fsPath}`\n            );\n        } else {\n            targetFolder = folderUri;\n            boostLogging.debug(\n                `Analyzing Boost files in folder: ${folderUri.fsPath}`\n            );\n        }\n\n        let baseWorkspace;\n        if (vscode.workspace.workspaceFolders) {\n            baseWorkspace = vscode.workspace.workspaceFolders![0].uri;\n        } else {\n            baseWorkspace = folderUri;\n        }\n        // we're going to search for everything under our target folder, and let the notebook parsing code filter out what it can't handle\n        let searchPattern = new vscode.RelativePattern(\n            targetFolder.fsPath,\n            \"**/*\" + boostnb.NOTEBOOK_EXTENSION\n        );\n        let ignorePattern = await buildVSCodeIgnorePattern(false);\n        boostLogging.debug(\n            \"Skipping Boost Notebook files of pattern: \" + ignorePattern ??\n                \"none\"\n        );\n        let files = await vscode.workspace.findFiles(\n            searchPattern,\n            ignorePattern\n                ? new vscode.RelativePattern(targetFolder, ignorePattern)\n                : \"\"\n        );\n\n        boostLogging.debug(\n            \"Converting \" + files.length + \" files in folder: \" + targetFolder\n        );\n\n        try {\n            let convertedNotebookWaits: any[] = [];\n\n            files.filter(async (file) => {\n                convertedNotebookWaits.push(\n                    this.buildCurrentFileOutput(file, false, outputFormat)\n                );\n            });\n\n            await Promise.all(convertedNotebookWaits)\n                .then((convertedNotebooks) => {\n                    convertedNotebooks.forEach((convertedPdf: string) => {\n                        // we let user know the notebook was processed\n                        boostLogging.info(\n                            `Boost Notebook converted ${convertedPdf}`,\n                            false\n                        );\n                    });\n                    boostLogging.info(\n                        `${convertedNotebookWaits.length.toString()} Boost Notebooks converted for folder ${\n                            targetFolder.fsPath\n                        }`,\n                        false\n                    );\n                })\n                .catch((error) => {\n                    // Handle the error here\n                    boostLogging.error(\n                        `Error convertting Notebooks in folder ${targetFolder.fsPath} due to Error: ${error}`\n                    );\n                });\n        } catch (error) {\n            boostLogging.error(\n                `Unable to Convert Notebooks in Folder:[${folderUri.fsPath.toString()} due to error:${error}`\n            );\n        }\n    }\n\n    public getSummaries(analysisType: BoostUserAnalysisType): string[] {\n        const summaries: string[] = [];\n        const projectSummaryFile = getBoostFile(\n            undefined,\n            BoostFileType.summary,\n            false\n        );\n        if (projectSummaryFile && fs.existsSync(projectSummaryFile.fsPath)) {\n            const projectSummary = new boostnb.BoostNotebook();\n            projectSummary.load(projectSummaryFile.fsPath);\n            let outputType;\n            switch (analysisType) {\n                case BoostUserAnalysisType.blueprint:\n                    outputType = ControllerOutputType.blueprint;\n                    break;\n                case BoostUserAnalysisType.compliance:\n                    outputType = ControllerOutputType.compliance;\n                    break;\n                case BoostUserAnalysisType.security:\n                    outputType = ControllerOutputType.analyze;\n                    break;\n                case BoostUserAnalysisType.documentation:\n                    outputType = ControllerOutputType.explain;\n                    break;\n                default:\n                    throw new Error(`Unknown analysis type ${analysisType}`);\n            }\n            const summaryCell = findCellByKernel(\n                projectSummary,\n                outputType\n            ) as boostnb.BoostNotebookCell;\n            if (summaryCell) {\n                summaries.push(summaryCell.value);\n            }\n        }\n        return summaries;\n    }\n}\n",
      "kind": 2,
      "metadata": {
        "id": 35,
        "type": "originalCode",
        "lineNumberBase": 95
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./src/BoostExtension.ts"
  }
}