{
  "cells": [
    {
      "outputs": [],
      "languageId": "c",
      "id": "0",
      "value": "/* ssl/d1_both.c */\n/* \n * DTLS implementation written by Nagendra Modadugu\n * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.  \n */\n/* ====================================================================\n * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    openssl-core@openssl.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n * \n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n * \n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the rouines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from \n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n * \n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * \n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.]\n */\n\n#include <limits.h>\n#include <string.h>\n#include <stdio.h>\n#include \"ssl_locl.h\"\n#include <openssl/buffer.h>\n#include <openssl/rand.h>\n#include <openssl/objects.h>\n#include <openssl/evp.h>\n#include <openssl/x509.h>\n\n#define RSMBLY_BITMASK_SIZE(msg_len) (((msg_len) + 7) / 8)\n\n#define RSMBLY_BITMASK_MARK(bitmask, start, end) { \\\n\t\t\tif ((end) - (start) <= 8) { \\\n\t\t\t\tlong ii; \\\n\t\t\t\tfor (ii = (start); ii < (end); ii++) bitmask[((ii) >> 3)] |= (1 << ((ii) & 7)); \\\n\t\t\t} else { \\\n\t\t\t\tlong ii; \\\n\t\t\t\tbitmask[((start) >> 3)] |= bitmask_start_values[((start) & 7)]; \\\n\t\t\t\tfor (ii = (((start) >> 3) + 1); ii < ((((end) - 1)) >> 3); ii++) bitmask[ii] = 0xff; \\\n\t\t\t\tbitmask[(((end) - 1) >> 3)] |= bitmask_end_values[((end) & 7)]; \\\n\t\t\t} }\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 126
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "1",
      "value": "\n#define RSMBLY_BITMASK_IS_COMPLETE(bitmask, msg_len, is_complete) { \\\n\t\t\tlong ii; \\\n\t\t\tOPENSSL_assert((msg_len) > 0); \\\n\t\t\tis_complete = 1; \\\n\t\t\tif (bitmask[(((msg_len) - 1) >> 3)] != bitmask_end_values[((msg_len) & 7)]) is_complete = 0; \\\n\t\t\tif (is_complete) for (ii = (((msg_len) - 1) >> 3) - 1; ii >= 0 ; ii--) \\\n\t\t\t\tif (bitmask[ii] != 0xff) { is_complete = 0; break; } }\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 137
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "2",
      "value": "\n#if 0\n#define RSMBLY_BITMASK_PRINT(bitmask, msg_len) { \\\n\t\t\tlong ii; \\\n\t\t\tprintf(\"bitmask: \"); for (ii = 0; ii < (msg_len); ii++) \\\n\t\t\tprintf(\"%d \", (bitmask[ii >> 3] & (1 << (ii & 7))) >> (ii & 7)); \\\n\t\t\tprintf(\"\\n\"); }\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 146
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "3",
      "value": "#endif\n\nstatic unsigned char bitmask_start_values[] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80};\n",
      "kind": 2,
      "metadata": {
        "id": 3,
        "type": "originalCode",
        "lineNumberBase": 153
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "4",
      "value": "static unsigned char bitmask_end_values[]   = {0xff, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f};\n",
      "kind": 2,
      "metadata": {
        "id": 4,
        "type": "originalCode",
        "lineNumberBase": 154
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "5",
      "value": "\n/* XDTLS:  figure out the right values */\nstatic unsigned int g_probable_mtu[] = {1500 - 28, 512 - 28, 256 - 28};\n",
      "kind": 2,
      "metadata": {
        "id": 5,
        "type": "originalCode",
        "lineNumberBase": 157
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "6",
      "value": "\nstatic unsigned int dtls1_guess_mtu(unsigned int curr_mtu);\nstatic void dtls1_fix_message_header(SSL *s, unsigned long frag_off, \n\tunsigned long frag_len);\nstatic unsigned char *dtls1_write_message_header(SSL *s,\n\tunsigned char *p);\nstatic void dtls1_set_message_header_int(SSL *s, unsigned char mt,\n\tunsigned long len, unsigned short seq_num, unsigned long frag_off, \n\tunsigned long frag_len);\nstatic long dtls1_get_message_fragment(SSL *s, int st1, int stn, \n\tlong max, int *ok);\n\nstatic hm_fragment *\ndtls1_hm_fragment_new(unsigned long frag_len, int reassembly)\n\t{\n\thm_fragment *frag = NULL;\n\tunsigned char *buf = NULL;\n\tunsigned char *bitmask = NULL;\n\n\tfrag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));\n\tif ( frag == NULL)\n\t\treturn NULL;\n\n\tif (frag_len)\n\t\t{\n\t\tbuf = (unsigned char *)OPENSSL_malloc(frag_len);\n\t\tif ( buf == NULL)\n\t\t\t{\n\t\t\tOPENSSL_free(frag);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t/* zero length fragment gets zero frag->fragment */\n\tfrag->fragment = buf;\n\n\t/* Initialize reassembly bitmask if necessary */\n\tif (reassembly)\n\t\t{\n\t\tbitmask = (unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));\n\t\tif (bitmask == NULL)\n\t\t\t{\n\t\t\tif (buf != NULL) OPENSSL_free(buf);\n\t\t\tOPENSSL_free(frag);\n\t\t\treturn NULL;\n\t\t\t}\n\t\tmemset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));\n\t\t}\n\n\tfrag->reassembly = bitmask;\n\n\treturn frag;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 6,
        "type": "originalCode",
        "lineNumberBase": 172
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "7",
      "value": "\nstatic void\ndtls1_hm_fragment_free(hm_fragment *frag)\n\t{\n\tif (frag->fragment) OPENSSL_free(frag->fragment);\n\tif (frag->reassembly) OPENSSL_free(frag->reassembly);\n\tOPENSSL_free(frag);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 7,
        "type": "originalCode",
        "lineNumberBase": 214
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "8",
      "value": "\n/* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */\nint dtls1_do_write(SSL *s, int type)\n\t{\n\tint ret;\n\tint curr_mtu;\n\tunsigned int len, frag_off, mac_size, blocksize;\n\n\t/* AHA!  Figure out the MTU, and stick to the right size */\n\tif ( ! (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))\n\t\t{\n\t\ts->d1->mtu = \n\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);\n\n\t\t/* I've seen the kernel return bogus numbers when it doesn't know\n\t\t * (initial write), so just make sure we have a reasonable number */\n\t\tif ( s->d1->mtu < dtls1_min_mtu())\n\t\t\t{\n\t\t\ts->d1->mtu = 0;\n\t\t\ts->d1->mtu = dtls1_guess_mtu(s->d1->mtu);\n\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU, \n\t\t\t\ts->d1->mtu, NULL);\n\t\t\t}\n\t\t}\n#if 0 \n\tmtu = s->d1->mtu;\n\n\tfprintf(stderr, \"using MTU = %d\\n\", mtu);\n\n\tmtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);\n\n\tcurr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));\n\n\tif ( curr_mtu > 0)\n\t\tmtu = curr_mtu;\n\telse if ( ( ret = BIO_flush(SSL_get_wbio(s))) <= 0)\n\t\treturn ret;\n\n\tif ( BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu)\n\t\t{\n\t\tret = BIO_flush(SSL_get_wbio(s));\n\t\tif ( ret <= 0)\n\t\t\treturn ret;\n\t\tmtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);\n\t\t}\n#endif\n\n\tOPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());  /* should have something reasonable now */\n\n\tif ( s->init_off == 0  && type == SSL3_RT_HANDSHAKE)\n\t\tOPENSSL_assert(s->init_num == \n\t\t\t(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);\n\n\tif (s->write_hash)\n\t\tmac_size = EVP_MD_CTX_size(s->write_hash);\n\telse\n\t\tmac_size = 0;\n\n\tif (s->enc_write_ctx && \n\t\t(EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))\n\t\tblocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);\n\telse\n\t\tblocksize = 0;\n\n\tfrag_off = 0;\n\twhile( s->init_num)\n\t\t{\n\t\tcurr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) - \n\t\t\tDTLS1_RT_HEADER_LENGTH - mac_size - blocksize;\n\n\t\tif ( curr_mtu <= DTLS1_HM_HEADER_LENGTH)\n\t\t\t{\n\t\t\t/* grr.. we could get an error if MTU picked was wrong */\n\t\t\tret = BIO_flush(SSL_get_wbio(s));\n\t\t\tif ( ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tcurr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH -\n\t\t\t\tmac_size - blocksize;\n\t\t\t}\n\n\t\tif ( s->init_num > curr_mtu)\n\t\t\tlen = curr_mtu;\n\t\telse\n\t\t\tlen = s->init_num;\n\n\n\t\t/* XDTLS: this function is too long.  split out the CCS part */\n\t\tif ( type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tif ( s->init_off != 0)\n\t\t\t\t{\n\t\t\t\tOPENSSL_assert(s->init_off > DTLS1_HM_HEADER_LENGTH);\n\t\t\t\ts->init_off -= DTLS1_HM_HEADER_LENGTH;\n\t\t\t\ts->init_num += DTLS1_HM_HEADER_LENGTH;\n\n\t\t\t\t/* write atleast DTLS1_HM_HEADER_LENGTH bytes */\n\t\t\t\tif ( len <= DTLS1_HM_HEADER_LENGTH)  \n\t\t\t\t\tlen += DTLS1_HM_HEADER_LENGTH;\n\t\t\t\t}\n\n\t\t\tdtls1_fix_message_header(s, frag_off, \n\t\t\t\tlen - DTLS1_HM_HEADER_LENGTH);\n\n\t\t\tdtls1_write_message_header(s, (unsigned char *)&s->init_buf->data[s->init_off]);\n\n\t\t\tOPENSSL_assert(len >= DTLS1_HM_HEADER_LENGTH);\n\t\t\t}\n\n\t\tret=dtls1_write_bytes(s,type,&s->init_buf->data[s->init_off],\n\t\t\tlen);\n\t\tif (ret < 0)\n\t\t\t{\n\t\t\t/* might need to update MTU here, but we don't know\n\t\t\t * which previous packet caused the failure -- so can't\n\t\t\t * really retransmit anything.  continue as if everything\n\t\t\t * is fine and wait for an alert to handle the\n\t\t\t * retransmit \n\t\t\t */\n\t\t\tif ( BIO_ctrl(SSL_get_wbio(s),\n\t\t\t\tBIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0 )\n\t\t\t\ts->d1->mtu = BIO_ctrl(SSL_get_wbio(s),\n\t\t\t\t\tBIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);\n\t\t\telse\n\t\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\n\t\t\t/* bad if this assert fails, only part of the handshake\n\t\t\t * message got sent.  but why would this happen? */\n\t\t\tOPENSSL_assert(len == (unsigned int)ret);\n\n\t\t\tif (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting)\n\t\t\t\t{\n\t\t\t\t/* should not be done for 'Hello Request's, but in that case\n\t\t\t\t * we'll ignore the result anyway */\n\t\t\t\tunsigned char *p = (unsigned char *)&s->init_buf->data[s->init_off];\n\t\t\t\tconst struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n\t\t\t\tint xlen;\n\n\t\t\t\tif (frag_off == 0 && s->version != DTLS1_BAD_VER)\n\t\t\t\t\t{\n\t\t\t\t\t/* reconstruct message header is if it\n\t\t\t\t\t * is being sent in single fragment */\n\t\t\t\t\t*p++ = msg_hdr->type;\n\t\t\t\t\tl2n3(msg_hdr->msg_len,p);\n\t\t\t\t\ts2n (msg_hdr->seq,p);\n\t\t\t\t\tl2n3(0,p);\n\t\t\t\t\tl2n3(msg_hdr->msg_len,p);\n\t\t\t\t\tp  -= DTLS1_HM_HEADER_LENGTH;\n\t\t\t\t\txlen = ret;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tp  += DTLS1_HM_HEADER_LENGTH;\n\t\t\t\t\txlen = ret - DTLS1_HM_HEADER_LENGTH;\n\t\t\t\t\t}\n\n\t\t\t\tssl3_finish_mac(s, p, xlen);\n\t\t\t\t}\n\n\t\t\tif (ret == s->init_num)\n\t\t\t\t{\n\t\t\t\tif (s->msg_callback)\n\t\t\t\t\ts->msg_callback(1, s->version, type, s->init_buf->data, \n\t\t\t\t\t\t(size_t)(s->init_off + s->init_num), s, \n\t\t\t\t\t\ts->msg_callback_arg);\n\n\t\t\t\ts->init_off = 0;  /* done writing this message */\n\t\t\t\ts->init_num = 0;\n\n\t\t\t\treturn(1);\n\t\t\t\t}\n\t\t\ts->init_off+=ret;\n\t\t\ts->init_num-=ret;\n\t\t\tfrag_off += (ret -= DTLS1_HM_HEADER_LENGTH);\n\t\t\t}\n\t\t}\n\treturn(0);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 8,
        "type": "originalCode",
        "lineNumberBase": 222
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "9",
      "value": "\n\n/* Obtain handshake message of message type 'mt' (any if mt == -1),\n * maximum acceptable body length 'max'.\n * Read an entire handshake message.  Handshake messages arrive in\n * fragments.\n */\nlong dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tint i, al;\n\tstruct hm_header_st *msg_hdr;\n\tunsigned char *p;\n\tunsigned long msg_len;\n\n\t/* s3->tmp is used to store messages that are unexpected, caused\n\t * by the absence of an optional handshake message */\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\ts->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\n\t\ts->init_num = (int)s->s3->tmp.message_size;\n\t\treturn s->init_num;\n\t\t}\n\n\tmsg_hdr = &s->d1->r_msg_hdr;\n\tmemset(msg_hdr, 0x00, sizeof(struct hm_header_st));\n\nagain:\n\ti = dtls1_get_message_fragment(s, st1, stn, max, ok);\n\tif ( i == DTLS1_HM_BAD_FRAGMENT ||\n\t\ti == DTLS1_HM_FRAGMENT_RETRY)  /* bad fragment received */\n\t\tgoto again;\n\telse if ( i <= 0 && !*ok)\n\t\treturn i;\n\n\tp = (unsigned char *)s->init_buf->data;\n\tmsg_len = msg_hdr->msg_len;\n\n\t/* reconstruct message header */\n\t*(p++) = msg_hdr->type;\n\tl2n3(msg_len,p);\n\ts2n (msg_hdr->seq,p);\n\tl2n3(0,p);\n\tl2n3(msg_len,p);\n\tif (s->version != DTLS1_BAD_VER) {\n\t\tp       -= DTLS1_HM_HEADER_LENGTH;\n\t\tmsg_len += DTLS1_HM_HEADER_LENGTH;\n\t}\n\n\tssl3_finish_mac(s, p, msg_len);\n\tif (s->msg_callback)\n\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n\t\t\tp, msg_len,\n\t\t\ts, s->msg_callback_arg);\n\n\tmemset(msg_hdr, 0x00, sizeof(struct hm_header_st));\n\n\t/* Don't change sequence numbers while listening */\n\tif (!s->d1->listen)\n\t\ts->d1->handshake_read_seq++;\n\n\ts->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\n\treturn s->init_num;\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t*ok = 0;\n\treturn -1;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 9,
        "type": "originalCode",
        "lineNumberBase": 407
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "10",
      "value": "\n\nstatic int dtls1_preprocess_fragment(SSL *s,struct hm_header_st *msg_hdr,int max)\n\t{\n\tsize_t frag_off,frag_len,msg_len;\n\n\tmsg_len  = msg_hdr->msg_len;\n\tfrag_off = msg_hdr->frag_off;\n\tfrag_len = msg_hdr->frag_len;\n\n\t/* sanity checking */\n\tif ( (frag_off+frag_len) > msg_len)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\treturn SSL_AD_ILLEGAL_PARAMETER;\n\t\t}\n\n\tif ( (frag_off+frag_len) > (unsigned long)max)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\treturn SSL_AD_ILLEGAL_PARAMETER;\n\t\t}\n\n\tif ( s->d1->r_msg_hdr.frag_off == 0) /* first fragment */\n\t\t{\n\t\t/* msg_len is limited to 2^24, but is effectively checked\n\t\t * against max above */\n\t\tif (!BUF_MEM_grow_clean(s->init_buf,msg_len+DTLS1_HM_HEADER_LENGTH))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,ERR_R_BUF_LIB);\n\t\t\treturn SSL_AD_INTERNAL_ERROR;\n\t\t\t}\n\n\t\ts->s3->tmp.message_size  = msg_len;\n\t\ts->d1->r_msg_hdr.msg_len = msg_len;\n\t\ts->s3->tmp.message_type  = msg_hdr->type;\n\t\ts->d1->r_msg_hdr.type    = msg_hdr->type;\n\t\ts->d1->r_msg_hdr.seq     = msg_hdr->seq;\n\t\t}\n\telse if (msg_len != s->d1->r_msg_hdr.msg_len)\n\t\t{\n\t\t/* They must be playing with us! BTW, failure to enforce\n\t\t * upper limit would open possibility for buffer overrun. */\n\t\tSSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\treturn SSL_AD_ILLEGAL_PARAMETER;\n\t\t}\n\n\treturn 0; /* no error */\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 10,
        "type": "originalCode",
        "lineNumberBase": 478
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "11",
      "value": "\n\nstatic int\ndtls1_retrieve_buffered_fragment(SSL *s, long max, int *ok)\n\t{\n\t/* (0) check whether the desired fragment is available\n\t * if so:\n\t * (1) copy over the fragment to s->init_buf->data[]\n\t * (2) update s->init_num\n\t */\n\tpitem *item;\n\thm_fragment *frag;\n\tint al;\n\n\t*ok = 0;\n\titem = pqueue_peek(s->d1->buffered_messages);\n\tif ( item == NULL)\n\t\treturn 0;\n\n\tfrag = (hm_fragment *)item->data;\n\t\n\t/* Don't return if reassembly still in progress */\n\tif (frag->reassembly != NULL)\n\t\treturn 0;\n\n\tif ( s->d1->handshake_read_seq == frag->msg_header.seq)\n\t\t{\n\t\tunsigned long frag_len = frag->msg_header.frag_len;\n\t\tpqueue_pop(s->d1->buffered_messages);\n\n\t\tal=dtls1_preprocess_fragment(s,&frag->msg_header,max);\n\n\t\tif (al==0) /* no alert */\n\t\t\t{\n\t\t\tunsigned char *p = (unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;\n\t\t\tmemcpy(&p[frag->msg_header.frag_off],\n\t\t\t\tfrag->fragment,frag->msg_header.frag_len);\n\t\t\t}\n\n\t\tdtls1_hm_fragment_free(frag);\n\t\tpitem_free(item);\n\n\t\tif (al==0)\n\t\t\t{\n\t\t\t*ok = 1;\n\t\t\treturn frag_len;\n\t\t\t}\n\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\ts->init_num = 0;\n\t\t*ok = 0;\n\t\treturn -1;\n\t\t}\n\telse\n\t\treturn 0;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 11,
        "type": "originalCode",
        "lineNumberBase": 528
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "12",
      "value": "\n\nstatic int\ndtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Determine maximum allowed message size. Depends on (user set)\n\t * maximum certificate length, but 16k is minimum.\n\t */\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n\t\tfrag->msg_header.frag_off = 0;\n\t\t}\n\telse\n\t\tfrag = (hm_fragment*) item->data;\n\n\t/* If message is already reassembled, this must be a\n\t * retransmit and can be dropped.\n\t */\n\tif (frag->reassembly == NULL)\n\t\t{\n\t\tunsigned char devnull [256];\n\n\t\twhile (frag_len)\n\t\t\t{\n\t\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t\tdevnull,\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n\t\treturn DTLS1_HM_FRAGMENT_RETRY;\n\t\t}\n\n\t/* read the body of the fragment (header has already been read */\n\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\tfrag->fragment + msg_hdr->frag_off,frag_len,0);\n\tif (i<=0 || (unsigned long)i!=frag_len)\n\t\tgoto err;\n\n\tRSMBLY_BITMASK_MARK(frag->reassembly, (long)msg_hdr->frag_off,\n\t                    (long)(msg_hdr->frag_off + frag_len));\n\n\tRSMBLY_BITMASK_IS_COMPLETE(frag->reassembly, (long)msg_hdr->msg_len,\n\t                           is_complete);\n\n\tif (is_complete)\n\t\t{\n\t\tOPENSSL_free(frag->reassembly);\n\t\tfrag->reassembly = NULL;\n\t\t}\n\n\tif (item == NULL)\n\t\t{\n\t\tmemset(seq64be,0,sizeof(seq64be));\n\t\tseq64be[6] = (unsigned char)(msg_hdr->seq>>8);\n\t\tseq64be[7] = (unsigned char)(msg_hdr->seq);\n\n\t\titem = pitem_new(seq64be, frag);\n\t\tif (item == NULL)\n\t\t\t{\n\t\t\tgoto err;\n\t\t\ti = -1;\n\t\t\t}\n\n\t\tpqueue_insert(s->d1->buffered_messages, item);\n\t\t}\n\n\treturn DTLS1_HM_FRAGMENT_RETRY;\n\nerr:\n\tif (frag != NULL) dtls1_hm_fragment_free(frag);\n\tif (item != NULL) OPENSSL_free(item);\n\t*ok = 0;\n\treturn i;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 12,
        "type": "originalCode",
        "lineNumberBase": 584
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "13",
      "value": "\n\nstatic int\ndtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n{\n\tint i=-1;\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue, to prevent duplicate entries */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\t/* If we already have an entry and this one is a fragment,\n\t * don't discard it and rather try to reassemble it.\n\t */\n\tif (item != NULL && frag_len < msg_hdr->msg_len)\n\t\titem = NULL;\n\n\t/* Discard the message if sequence number was already there, is\n\t * too far in the future, already in the queue or if we received\n\t * a FINISHED before the SERVER_HELLO, which then must be a stale\n\t * retransmit.\n\t */\n\tif (msg_hdr->seq <= s->d1->handshake_read_seq ||\n\t\tmsg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL ||\n\t\t(s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED))\n\t\t{\n\t\tunsigned char devnull [256];\n\n\t\twhile (frag_len)\n\t\t\t{\n\t\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t\tdevnull,\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (frag_len && frag_len < msg_hdr->msg_len)\n\t\t\treturn dtls1_reassemble_fragment(s, msg_hdr, ok);\n\n\t\tfrag = dtls1_hm_fragment_new(frag_len, 0);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\n\t\tif (frag_len)\n\t\t\t{\n\t\t\t/* read the body of the fragment (header has already been read */\n\t\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t\tfrag->fragment,frag_len,0);\n\t\t\tif (i<=0 || (unsigned long)i!=frag_len)\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\tmemset(seq64be,0,sizeof(seq64be));\n\t\tseq64be[6] = (unsigned char)(msg_hdr->seq>>8);\n\t\tseq64be[7] = (unsigned char)(msg_hdr->seq);\n\n\t\titem = pitem_new(seq64be, frag);\n\t\tif ( item == NULL)\n\t\t\tgoto err;\n\n\t\tpqueue_insert(s->d1->buffered_messages, item);\n\t\t}\n\n\treturn DTLS1_HM_FRAGMENT_RETRY;\n\nerr:\n\tif ( frag != NULL) dtls1_hm_fragment_free(frag);\n\tif ( item != NULL) OPENSSL_free(item);\n\t*ok = 0;\n\treturn i;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 13,
        "type": "originalCode",
        "lineNumberBase": 687
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "14",
      "value": "\n\nstatic long\ndtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)\n\t{\n\tunsigned char wire[DTLS1_HM_HEADER_LENGTH];\n\tunsigned long len, frag_off, frag_len;\n\tint i,al;\n\tstruct hm_header_st msg_hdr;\n\n\t/* see if we have the required fragment already */\n\tif ((frag_len = dtls1_retrieve_buffered_fragment(s,max,ok)) || *ok)\n\t\t{\n\t\tif (*ok)\ts->init_num = frag_len;\n\t\treturn frag_len;\n\t\t}\n\n\t/* read handshake message header */\n\ti=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,wire,\n\t\tDTLS1_HM_HEADER_LENGTH, 0);\n\tif (i <= 0) \t/* nbio, or an error */\n\t\t{\n\t\ts->rwstate=SSL_READING;\n\t\t*ok = 0;\n\t\treturn i;\n\t\t}\n\t/* Handshake fails if message header is incomplete */\n\tif (i != DTLS1_HM_HEADER_LENGTH)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n\n\t/* parse the message fragment header */\n\tdtls1_get_message_header(wire, &msg_hdr);\n\n\t/* \n\t * if this is a future (or stale) message it gets buffered\n\t * (or dropped)--no further processing at this time\n\t * While listening, we accept seq 1 (ClientHello with cookie)\n\t * although we're still expecting seq 0 (ClientHello)\n\t */\n\tif (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))\n\t\treturn dtls1_process_out_of_seq_message(s, &msg_hdr, ok);\n\n\tlen = msg_hdr.msg_len;\n\tfrag_off = msg_hdr.frag_off;\n\tfrag_len = msg_hdr.frag_len;\n\n\tif (frag_len && frag_len < len)\n\t\treturn dtls1_reassemble_fragment(s, &msg_hdr, ok);\n\n\tif (!s->server && s->d1->r_msg_hdr.frag_off == 0 &&\n\t\twire[0] == SSL3_MT_HELLO_REQUEST)\n\t\t{\n\t\t/* The server may always send 'Hello Request' messages --\n\t\t * we are doing a handshake anyway now, so ignore them\n\t\t * if their format is correct. Does not count for\n\t\t * 'Finished' MAC. */\n\t\tif (wire[1] == 0 && wire[2] == 0 && wire[3] == 0)\n\t\t\t{\n\t\t\tif (s->msg_callback)\n\t\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, \n\t\t\t\t\twire, DTLS1_HM_HEADER_LENGTH, s, \n\t\t\t\t\ts->msg_callback_arg);\n\t\t\t\n\t\t\ts->init_num = 0;\n\t\t\treturn dtls1_get_message_fragment(s, st1, stn,\n\t\t\t\tmax, ok);\n\t\t\t}\n\t\telse /* Incorrectly formated Hello request */\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\n\tif ((al=dtls1_preprocess_fragment(s,&msg_hdr,max)))\n\t\tgoto f_err;\n\n\t/* XDTLS:  ressurect this when restart is in place */\n\ts->state=stn;\n\n\tif ( frag_len > 0)\n\t\t{\n\t\tunsigned char *p=(unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;\n\n\t\ti=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t&p[frag_off],frag_len,0);\n\t\t/* XDTLS:  fix this--message fragments cannot span multiple packets */\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\t}\n\telse\n\t\ti = 0;\n\n\t/* XDTLS:  an incorrectly formatted fragment should cause the \n\t * handshake to fail */\n\tif (i != (int)frag_len)\n\t\t{\n\t\tal=SSL3_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL3_AD_ILLEGAL_PARAMETER);\n\t\tgoto f_err;\n\t\t}\n\n\t*ok = 1;\n\n\t/* Note that s->init_num is *not* used as current offset in\n\t * s->init_buf->data, but as a counter summing up fragments'\n\t * lengths: as soon as they sum up to handshake packet\n\t * length, we assume we have got all the fragments. */\n\ts->init_num = frag_len;\n\treturn frag_len;\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\ts->init_num = 0;\n\n\t*ok=0;\n\treturn(-1);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 14,
        "type": "originalCode",
        "lineNumberBase": 772
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "15",
      "value": "\nint dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)\n\t{\n\tunsigned char *p,*d;\n\tint i;\n\tunsigned long l;\n\n\tif (s->state == a)\n\t\t{\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tp= &(d[DTLS1_HM_HEADER_LENGTH]);\n\n\t\ti=s->method->ssl3_enc->final_finish_mac(s,\n\t\t\tsender,slen,s->s3->tmp.finish_md);\n\t\ts->s3->tmp.finish_md_len = i;\n\t\tmemcpy(p, s->s3->tmp.finish_md, i);\n\t\tp+=i;\n\t\tl=i;\n\n\t/* Copy the finished so we can use it for\n\t * renegotiation checks\n\t */\n\tif(s->type == SSL_ST_CONNECT)\n\t\t{\n\t\tOPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n\t\tmemcpy(s->s3->previous_client_finished, \n\t\t       s->s3->tmp.finish_md, i);\n\t\ts->s3->previous_client_finished_len=i;\n\t\t}\n\telse\n\t\t{\n\t\tOPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n\t\tmemcpy(s->s3->previous_server_finished, \n\t\t       s->s3->tmp.finish_md, i);\n\t\ts->s3->previous_server_finished_len=i;\n\t\t}\n\n#ifdef OPENSSL_SYS_WIN16\n\t\t/* MSVC 1.5 does not clear the top bytes of the word unless\n\t\t * I do this.\n\t\t */\n\t\tl&=0xffff;\n#endif\n\n\t\td = dtls1_set_message_header(s, d, SSL3_MT_FINISHED, l, 0, l);\n\t\ts->init_num=(int)l+DTLS1_HM_HEADER_LENGTH;\n\t\ts->init_off=0;\n\n\t\t/* buffer the message to handle re-xmits */\n\t\tdtls1_buffer_message(s, 0);\n\n\t\ts->state=b;\n\t\t}\n\n\t/* SSL3_ST_SEND_xxxxxx_HELLO_B */\n\treturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 15,
        "type": "originalCode",
        "lineNumberBase": 897
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "16",
      "value": "\n/* for these 2 messages, we need to\n * ssl->enc_read_ctx\t\t\tre-init\n * ssl->s3->read_sequence\t\tzero\n * ssl->s3->read_mac_secret\t\tre-init\n * ssl->session->read_sym_enc\t\tassign\n * ssl->session->read_compression\tassign\n * ssl->session->read_hash\t\tassign\n */\nint dtls1_send_change_cipher_spec(SSL *s, int a, int b)\n\t{ \n\tunsigned char *p;\n\n\tif (s->state == a)\n\t\t{\n\t\tp=(unsigned char *)s->init_buf->data;\n\t\t*p++=SSL3_MT_CCS;\n\t\ts->d1->handshake_write_seq = s->d1->next_handshake_write_seq;\n\t\ts->init_num=DTLS1_CCS_HEADER_LENGTH;\n\n\t\tif (s->version == DTLS1_BAD_VER) {\n\t\t\ts->d1->next_handshake_write_seq++;\n\t\t\ts2n(s->d1->handshake_write_seq,p);\n\t\t\ts->init_num+=2;\n\t\t}\n\n\t\ts->init_off=0;\n\n\t\tdtls1_set_message_header_int(s, SSL3_MT_CCS, 0, \n\t\t\ts->d1->handshake_write_seq, 0, 0);\n\n\t\t/* buffer the message to handle re-xmits */\n\t\tdtls1_buffer_message(s, 1);\n\n\t\ts->state=b;\n\t\t}\n\n\t/* SSL3_ST_CW_CHANGE_B */\n\treturn(dtls1_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC));\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 16,
        "type": "originalCode",
        "lineNumberBase": 962
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "17",
      "value": "\nstatic int dtls1_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)\n\t{\n\tint n;\n\tunsigned char *p;\n\n\tn=i2d_X509(x,NULL);\n\tif (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);\n\t\treturn 0;\n\t\t}\n\tp=(unsigned char *)&(buf->data[*l]);\n\tl2n3(n,p);\n\ti2d_X509(x,&p);\n\t*l+=n+3;\n\n\treturn 1;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 17,
        "type": "originalCode",
        "lineNumberBase": 994
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "18",
      "value": "unsigned long dtls1_output_cert_chain(SSL *s, X509 *x)\n\t{\n\tunsigned char *p;\n\tint i;\n\tunsigned long l= 3 + DTLS1_HM_HEADER_LENGTH;\n\tBUF_MEM *buf;\n\n\t/* TLSv1 sends a chain with nothing in it, instead of an alert */\n\tbuf=s->init_buf;\n\tif (!BUF_MEM_grow_clean(buf,10))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\n\t\treturn(0);\n\t\t}\n\tif (x != NULL)\n\t\t{\n\t\tX509_STORE_CTX xs_ctx;\n\n\t\tif (!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,x,NULL))\n  \t\t\t{\n  \t\t\tSSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);\n  \t\t\treturn(0);\n  \t\t\t}\n  \n\t\tX509_verify_cert(&xs_ctx);\n\t\t/* Don't leave errors in the queue */\n\t\tERR_clear_error();\n\t\tfor (i=0; i < sk_X509_num(xs_ctx.chain); i++)\n  \t\t\t{\n\t\t\tx = sk_X509_value(xs_ctx.chain, i);\n\n\t\t\tif (!dtls1_add_cert_to_buf(buf, &l, x))\n  \t\t\t\t{\n\t\t\t\tX509_STORE_CTX_cleanup(&xs_ctx);\n\t\t\t\treturn 0;\n  \t\t\t\t}\n  \t\t\t}\n  \t\tX509_STORE_CTX_cleanup(&xs_ctx);\n  \t\t}\n  \t/* Thawte special :-) */\n\tfor (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)\n\t\t{\n\t\tx=sk_X509_value(s->ctx->extra_certs,i);\n\t\tif (!dtls1_add_cert_to_buf(buf, &l, x))\n\t\t\treturn 0;\n\t\t}\n\n\tl-= (3 + DTLS1_HM_HEADER_LENGTH);\n\n\tp=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);\n\tl2n3(l,p);\n\tl+=3;\n\tp=(unsigned char *)&(buf->data[0]);\n\tp = dtls1_set_message_header(s, p, SSL3_MT_CERTIFICATE, l, 0, l);\n\n\tl+=DTLS1_HM_HEADER_LENGTH;\n\treturn(l);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 18,
        "type": "originalCode",
        "lineNumberBase": 1012
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "19",
      "value": "\nint dtls1_read_failed(SSL *s, int code)\n\t{\n\tif ( code > 0)\n\t\t{\n\t\tfprintf( stderr, \"invalid state reached %s:%d\", __FILE__, __LINE__);\n\t\treturn 1;\n\t\t}\n\n\tif (!dtls1_is_timer_expired(s))\n\t\t{\n\t\t/* not a timeout, none of our business, \n\t\t   let higher layers handle this.  in fact it's probably an error */\n\t\treturn code;\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\tif (!SSL_in_init(s) && !s->tlsext_hb_pending)  /* done, no need to send a retransmit */\n#else\n\tif (!SSL_in_init(s))  /* done, no need to send a retransmit */\n#endif\n\t\t{\n\t\tBIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);\n\t\treturn code;\n\t\t}\n\n#if 0 /* for now, each alert contains only one record number */\n\titem = pqueue_peek(state->rcvd_records);\n\tif ( item )\n\t\t{\n\t\t/* send an alert immediately for all the missing records */\n\t\t}\n\telse\n#endif\n\n#if 0  /* no more alert sending, just retransmit the last set of messages */\n\tif ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)\n\t\tssl3_send_alert(s,SSL3_AL_WARNING,\n\t\t\tDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\n#endif\n\n\treturn dtls1_handle_timeout(s);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 19,
        "type": "originalCode",
        "lineNumberBase": 1071
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "20",
      "value": "\nint\ndtls1_get_queue_priority(unsigned short seq, int is_ccs)\n\t{\n\t/* The index of the retransmission queue actually is the message sequence number,\n\t * since the queue only contains messages of a single handshake. However, the\n\t * ChangeCipherSpec has no message sequence number and so using only the sequence\n\t * will result in the CCS and Finished having the same index. To prevent this,\n\t * the sequence number is multiplied by 2. In case of a CCS 1 is subtracted.\n\t * This does not only differ CSS and Finished, it also maintains the order of the\n\t * index (important for priority queues) and fits in the unsigned short variable.\n\t */\t\n\treturn seq * 2 - is_ccs;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 20,
        "type": "originalCode",
        "lineNumberBase": 1115
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "21",
      "value": "\nint\ndtls1_retransmit_buffered_messages(SSL *s)\n\t{\n\tpqueue sent = s->d1->sent_messages;\n\tpiterator iter;\n\tpitem *item;\n\thm_fragment *frag;\n\tint found = 0;\n\n\titer = pqueue_iterator(sent);\n\n\tfor ( item = pqueue_next(&iter); item != NULL; item = pqueue_next(&iter))\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\t\tif ( dtls1_retransmit_message(s,\n\t\t\t\t(unsigned short)dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs),\n\t\t\t\t0, &found) <= 0 && found)\n\t\t\t{\n\t\t\tfprintf(stderr, \"dtls1_retransmit_message() failed\\n\");\n\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\treturn 1;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 21,
        "type": "originalCode",
        "lineNumberBase": 1129
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "22",
      "value": "\nint\ndtls1_buffer_message(SSL *s, int is_ccs)\n\t{\n\tpitem *item;\n\thm_fragment *frag;\n\tunsigned char seq64be[8];\n\n\t/* this function is called immediately after a message has \n\t * been serialized */\n\tOPENSSL_assert(s->init_off == 0);\n\n\tfrag = dtls1_hm_fragment_new(s->init_num, 0);\n\n\tmemcpy(frag->fragment, s->init_buf->data, s->init_num);\n\n\tif ( is_ccs)\n\t\t{\n\t\tOPENSSL_assert(s->d1->w_msg_hdr.msg_len + \n\t\t\t       ((s->version==DTLS1_VERSION)?DTLS1_CCS_HEADER_LENGTH:3) == (unsigned int)s->init_num);\n\t\t}\n\telse\n\t\t{\n\t\tOPENSSL_assert(s->d1->w_msg_hdr.msg_len + \n\t\t\tDTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num);\n\t\t}\n\n\tfrag->msg_header.msg_len = s->d1->w_msg_hdr.msg_len;\n\tfrag->msg_header.seq = s->d1->w_msg_hdr.seq;\n\tfrag->msg_header.type = s->d1->w_msg_hdr.type;\n\tfrag->msg_header.frag_off = 0;\n\tfrag->msg_header.frag_len = s->d1->w_msg_hdr.msg_len;\n\tfrag->msg_header.is_ccs = is_ccs;\n\n\t/* save current state*/\n\tfrag->msg_header.saved_retransmit_state.enc_write_ctx = s->enc_write_ctx;\n\tfrag->msg_header.saved_retransmit_state.write_hash = s->write_hash;\n\tfrag->msg_header.saved_retransmit_state.compress = s->compress;\n\tfrag->msg_header.saved_retransmit_state.session = s->session;\n\tfrag->msg_header.saved_retransmit_state.epoch = s->d1->w_epoch;\n\t\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  frag->msg_header.is_ccs)>>8);\n\tseq64be[7] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  frag->msg_header.is_ccs));\n\n\titem = pitem_new(seq64be, frag);\n\tif ( item == NULL)\n\t\t{\n\t\tdtls1_hm_fragment_free(frag);\n\t\treturn 0;\n\t\t}\n\n#if 0\n\tfprintf( stderr, \"buffered messge: \\ttype = %xx\\n\", msg_buf->type);\n\tfprintf( stderr, \"\\t\\t\\t\\t\\tlen = %d\\n\", msg_buf->len);\n\tfprintf( stderr, \"\\t\\t\\t\\t\\tseq_num = %d\\n\", msg_buf->seq_num);\n#endif\n\n\tpqueue_insert(s->d1->sent_messages, item);\n\treturn 1;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 22,
        "type": "originalCode",
        "lineNumberBase": 1155
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "23",
      "value": "\nint\ndtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,\n\tint *found)\n\t{\n\tint ret;\n\t/* XDTLS: for now assuming that read/writes are blocking */\n\tpitem *item;\n\thm_fragment *frag ;\n\tunsigned long header_length;\n\tunsigned char seq64be[8];\n\tstruct dtls1_retransmit_state saved_state;\n\tunsigned char save_write_sequence[8];\n\n\t/*\n\t  OPENSSL_assert(s->init_num == 0);\n\t  OPENSSL_assert(s->init_off == 0);\n\t */\n\n\t/* XDTLS:  the requested message ought to be found, otherwise error */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char)(seq>>8);\n\tseq64be[7] = (unsigned char)seq;\n\n\titem = pqueue_find(s->d1->sent_messages, seq64be);\n\tif ( item == NULL)\n\t\t{\n\t\tfprintf(stderr, \"retransmit:  message %d non-existant\\n\", seq);\n\t\t*found = 0;\n\t\treturn 0;\n\t\t}\n\n\t*found = 1;\n\tfrag = (hm_fragment *)item->data;\n\n\tif ( frag->msg_header.is_ccs)\n\t\theader_length = DTLS1_CCS_HEADER_LENGTH;\n\telse\n\t\theader_length = DTLS1_HM_HEADER_LENGTH;\n\n\tmemcpy(s->init_buf->data, frag->fragment, \n\t\tfrag->msg_header.msg_len + header_length);\n\t\ts->init_num = frag->msg_header.msg_len + header_length;\n\n\tdtls1_set_message_header_int(s, frag->msg_header.type, \n\t\tfrag->msg_header.msg_len, frag->msg_header.seq, 0, \n\t\tfrag->msg_header.frag_len);\n\n\t/* save current state */\n\tsaved_state.enc_write_ctx = s->enc_write_ctx;\n\tsaved_state.write_hash = s->write_hash;\n\tsaved_state.compress = s->compress;\n\tsaved_state.session = s->session;\n\tsaved_state.epoch = s->d1->w_epoch;\n\tsaved_state.epoch = s->d1->w_epoch;\n\t\n\ts->d1->retransmitting = 1;\n\t\n\t/* restore state in which the message was originally sent */\n\ts->enc_write_ctx = frag->msg_header.saved_retransmit_state.enc_write_ctx;\n\ts->write_hash = frag->msg_header.saved_retransmit_state.write_hash;\n\ts->compress = frag->msg_header.saved_retransmit_state.compress;\n\ts->session = frag->msg_header.saved_retransmit_state.session;\n\ts->d1->w_epoch = frag->msg_header.saved_retransmit_state.epoch;\n\t\n\tif (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1)\n\t{\n\t\tmemcpy(save_write_sequence, s->s3->write_sequence, sizeof(s->s3->write_sequence));\n\t\tmemcpy(s->s3->write_sequence, s->d1->last_write_sequence, sizeof(s->s3->write_sequence));\n\t}\n\t\n\tret = dtls1_do_write(s, frag->msg_header.is_ccs ? \n\t\t\t\t\t\t SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);\n\t\n\t/* restore current state */\n\ts->enc_write_ctx = saved_state.enc_write_ctx;\n\ts->write_hash = saved_state.write_hash;\n\ts->compress = saved_state.compress;\n\ts->session = saved_state.session;\n\ts->d1->w_epoch = saved_state.epoch;\n\t\n\tif (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1)\n\t{\n\t\tmemcpy(s->d1->last_write_sequence, s->s3->write_sequence, sizeof(s->s3->write_sequence));\n\t\tmemcpy(s->s3->write_sequence, save_write_sequence, sizeof(s->s3->write_sequence));\n\t}\n\n\ts->d1->retransmitting = 0;\n\n\t(void)BIO_flush(SSL_get_wbio(s));\n\treturn ret;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 23,
        "type": "originalCode",
        "lineNumberBase": 1219
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "24",
      "value": "\n/* call this function when the buffered messages are no longer needed */\nvoid\ndtls1_clear_record_buffer(SSL *s)\n\t{\n\tpitem *item;\n\n\tfor(item = pqueue_pop(s->d1->sent_messages);\n\t\titem != NULL; item = pqueue_pop(s->d1->sent_messages))\n\t\t{\n\t\tdtls1_hm_fragment_free((hm_fragment *)item->data);\n\t\tpitem_free(item);\n\t\t}\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 24,
        "type": "originalCode",
        "lineNumberBase": 1311
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "25",
      "value": "\n\nunsigned char *\ndtls1_set_message_header(SSL *s, unsigned char *p, unsigned char mt,\n\t\t\tunsigned long len, unsigned long frag_off, unsigned long frag_len)\n\t{\n\t/* Don't change sequence numbers while listening */\n\tif (frag_off == 0 && !s->d1->listen)\n\t\t{\n\t\ts->d1->handshake_write_seq = s->d1->next_handshake_write_seq;\n\t\ts->d1->next_handshake_write_seq++;\n\t\t}\n\n\tdtls1_set_message_header_int(s, mt, len, s->d1->handshake_write_seq,\n\t\tfrag_off, frag_len);\n\n\treturn p += DTLS1_HM_HEADER_LENGTH;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 25,
        "type": "originalCode",
        "lineNumberBase": 1326
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "26",
      "value": "\n\n/* don't actually do the writing, wait till the MTU has been retrieved */\nstatic void\ndtls1_set_message_header_int(SSL *s, unsigned char mt,\n\t\t\t    unsigned long len, unsigned short seq_num, unsigned long frag_off,\n\t\t\t    unsigned long frag_len)\n\t{\n\tstruct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n\n\tmsg_hdr->type = mt;\n\tmsg_hdr->msg_len = len;\n\tmsg_hdr->seq = seq_num;\n\tmsg_hdr->frag_off = frag_off;\n\tmsg_hdr->frag_len = frag_len;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 26,
        "type": "originalCode",
        "lineNumberBase": 1346
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "27",
      "value": "\nstatic void\ndtls1_fix_message_header(SSL *s, unsigned long frag_off,\n\t\t\tunsigned long frag_len)\n\t{\n\tstruct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n\n\tmsg_hdr->frag_off = frag_off;\n\tmsg_hdr->frag_len = frag_len;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 27,
        "type": "originalCode",
        "lineNumberBase": 1359
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "28",
      "value": "\nstatic unsigned char *\ndtls1_write_message_header(SSL *s, unsigned char *p)\n\t{\n\tstruct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n\n\t*p++ = msg_hdr->type;\n\tl2n3(msg_hdr->msg_len, p);\n\n\ts2n(msg_hdr->seq, p);\n\tl2n3(msg_hdr->frag_off, p);\n\tl2n3(msg_hdr->frag_len, p);\n\n\treturn p;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 28,
        "type": "originalCode",
        "lineNumberBase": 1368
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "29",
      "value": "\nunsigned int \ndtls1_min_mtu(void)\n\t{\n\treturn (g_probable_mtu[(sizeof(g_probable_mtu) / \n\t\tsizeof(g_probable_mtu[0])) - 1]);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 29,
        "type": "originalCode",
        "lineNumberBase": 1383
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "30",
      "value": "\nstatic unsigned int \ndtls1_guess_mtu(unsigned int curr_mtu)\n\t{\n\tunsigned int i;\n\n\tif ( curr_mtu == 0 )\n\t\treturn g_probable_mtu[0] ;\n\n\tfor ( i = 0; i < sizeof(g_probable_mtu)/sizeof(g_probable_mtu[0]); i++)\n\t\tif ( curr_mtu > g_probable_mtu[i])\n\t\t\treturn g_probable_mtu[i];\n\n\treturn curr_mtu;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 30,
        "type": "originalCode",
        "lineNumberBase": 1390
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "31",
      "value": "\nvoid\ndtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)\n\t{\n\tmemset(msg_hdr, 0x00, sizeof(struct hm_header_st));\n\tmsg_hdr->type = *(data++);\n\tn2l3(data, msg_hdr->msg_len);\n\n\tn2s(data, msg_hdr->seq);\n\tn2l3(data, msg_hdr->frag_off);\n\tn2l3(data, msg_hdr->frag_len);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 31,
        "type": "originalCode",
        "lineNumberBase": 1405
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "32",
      "value": "\nvoid\ndtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr)\n\t{\n\tmemset(ccs_hdr, 0x00, sizeof(struct ccs_header_st));\n\n\tccs_hdr->type = *(data++);\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 32,
        "type": "originalCode",
        "lineNumberBase": 1417
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "33",
      "value": "\nint dtls1_shutdown(SSL *s)\n\t{\n\tint ret;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&\n\t    !(s->shutdown & SSL_SENT_SHUTDOWN))\n\t\t{\n\t\tret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));\n\t\tif (ret < 0) return -1;\n\n\t\tif (ret == 0)\n\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 1, NULL);\n\t\t}\n#endif\n\tret = ssl3_shutdown(s);\n#ifndef OPENSSL_NO_SCTP\n\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 0, NULL);\n#endif\n\treturn ret;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 33,
        "type": "originalCode",
        "lineNumberBase": 1424
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "34",
      "value": "\n#ifndef OPENSSL_NO_HEARTBEATS\nint\ndtls1_process_heartbeat(SSL *s)\n\t{\n\tunsigned char *p = &s->s3->rrec.data[0], *pl;\n\tunsigned short hbtype;\n\tunsigned int payload;\n\tunsigned int padding = 16; /* Use minimum padding */\n\n\t/* Read type and payload length first */\n\thbtype = *p++;\n\tn2s(p, payload);\n\tpl = p;\n\n\tif (s->msg_callback)\n\t\ts->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t&s->s3->rrec.data[0], s->s3->rrec.length,\n\t\t\ts, s->msg_callback_arg);\n\n\tif (hbtype == TLS1_HB_REQUEST)\n\t\t{\n\t\tunsigned char *buffer, *bp;\n\t\tint r;\n\n\t\t/* Allocate memory for the response, size is 1 byte\n\t\t * message type, plus 2 bytes payload length, plus\n\t\t * payload, plus padding\n\t\t */\n\t\tbuffer = OPENSSL_malloc(1 + 2 + payload + padding);\n\t\tbp = buffer;\n\n\t\t/* Enter response type, length and copy payload */\n\t\t*bp++ = TLS1_HB_RESPONSE;\n\t\ts2n(payload, bp);\n\t\tmemcpy(bp, pl, payload);\n\t\t/* Random padding */\n\t\tRAND_pseudo_bytes(p, padding);\n\n\t\tr = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);\n\n\t\tif (r >= 0 && s->msg_callback)\n\t\t\ts->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t\tbuffer, 3 + payload + padding,\n\t\t\t\ts, s->msg_callback_arg);\n\n\t\tOPENSSL_free(buffer);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\t}\n\telse if (hbtype == TLS1_HB_RESPONSE)\n\t\t{\n\t\tunsigned int seq;\n\n\t\t/* We only send sequence numbers (2 bytes unsigned int),\n\t\t * and 16 random bytes, so we just try to read the\n\t\t * sequence number */\n\t\tn2s(pl, seq);\n\n\t\tif (payload == 18 && seq == s->tlsext_hb_seq)\n\t\t\t{\n\t\t\tdtls1_stop_timer(s);\n\t\t\ts->tlsext_hb_seq++;\n\t\t\ts->tlsext_hb_pending = 0;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 34,
        "type": "originalCode",
        "lineNumberBase": 1447
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "35",
      "value": "\nint\ndtls1_heartbeat(SSL *s)\n\t{\n\tunsigned char *buf, *p;\n\tint ret;\n\tunsigned int payload = 18; /* Sequence number + random bytes */\n\tunsigned int padding = 16; /* Use minimum padding */\n\n\t/* Only send if peer supports and accepts HB requests... */\n\tif (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||\n\t    s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);\n\t\treturn -1;\n\t\t}\n\n\t/* ...and there is none in flight yet... */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PENDING);\n\t\treturn -1;\n\t\t}\n\n\t/* ...and no handshake in progress. */\n\tif (SSL_in_init(s) || s->in_handshake)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_UNEXPECTED_MESSAGE);\n\t\treturn -1;\n\t\t}\n\n\t/* Check if padding is too long, payload and padding\n\t * must not exceed 2^14 - 3 = 16381 bytes in total.\n\t */\n\tOPENSSL_assert(payload + padding <= 16381);\n\n\t/* Create HeartBeat message, we just use a sequence number\n\t * as payload to distuingish different messages and add\n\t * some random stuff.\n\t *  - Message Type, 1 byte\n\t *  - Payload Length, 2 bytes (unsigned int)\n\t *  - Payload, the sequence number (2 bytes uint)\n\t *  - Payload, random bytes (16 bytes uint)\n\t *  - Padding\n\t */\n\tbuf = OPENSSL_malloc(1 + 2 + payload + padding);\n\tp = buf;\n\t/* Message Type */\n\t*p++ = TLS1_HB_REQUEST;\n\t/* Payload length (18 bytes here) */\n\ts2n(payload, p);\n\t/* Sequence number */\n\ts2n(s->tlsext_hb_seq, p);\n\t/* 16 random bytes */\n\tRAND_pseudo_bytes(p, 16);\n\tp += 16;\n\t/* Random padding */\n\tRAND_pseudo_bytes(p, padding);\n\n\tret = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);\n\tif (ret >= 0)\n\t\t{\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t\tbuf, 3 + payload + padding,\n\t\t\t\ts, s->msg_callback_arg);\n\n\t\tdtls1_start_timer(s);\n\t\ts->tlsext_hb_pending = 1;\n\t\t}\n\n\tOPENSSL_free(buf);\n\n\treturn ret;\n\t}\n",
      "kind": 2,
      "metadata": {
        "id": 35,
        "type": "originalCode",
        "lineNumberBase": 1516
      }
    },
    {
      "outputs": [],
      "languageId": "c",
      "id": "36",
      "value": "#endif\n\n",
      "kind": 2,
      "metadata": {
        "id": 36,
        "type": "originalCode",
        "lineNumberBase": 1516
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./src/test/resources/heartbleed_d1_both.c"
  }
}