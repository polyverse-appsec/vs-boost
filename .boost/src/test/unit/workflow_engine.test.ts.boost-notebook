{
  "cells": [
    {
      "outputs": [
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Code Explanation\n\nLast Updated: Friday, September 8, 2023 at 7:17:24 PM PDT\n\nThe line of code you've provided is written in JavaScript and it's using a feature of the language called \"import\". Specifically, this line is importing a specific function called `expect` from a library called \"chai\".\n\nChai is a BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework. It provides a more readable and expressive language for writing assertions in your tests.\n\nThe `expect` function is one of the interfaces provided by the Chai library. It's used to write assertions about your code in your tests. Assertions are statements that assert or state a fact confidently in your program. For example, while writing a test, you might want to check that a function returns a certain value, or that a certain object has a certain property. You would use an assertion to do this.\n\nHere is an example of how the `expect` function might be used in a test:\n\n```javascript\nimport { expect } from \"chai\";\n\ndescribe('Array', function() {\n  describe('#indexOf()', function() {\n    it('should return -1 when the value is not present', function() {\n      expect([1, 2, 3].indexOf(5)).to.equal(-1);\n      expect([1, 2, 3].indexOf(0)).to.equal(-1);\n    });\n  });\n});\n```\n\nIn this example, the `expect` function is used to assert that the `indexOf` method of an array returns `-1` when the value is not present in the array.\n\nFor more information about the Chai library and the `expect` function, you can visit the [Chai documentation](https://www.chaijs.com/guide/styles/#expect).\n\nRegarding the architectural guidelines, as this is a single line of code used for testing, it doesn't conflict with any architectural guidelines. Using a well-known library like Chai for writing tests is a common practice and aligns with the general best practices of software development. However, the full context of the project would provide more information regarding its consistency with the overall architecture."
            }
          ],
          "metadata": {
            "outputType": "explainCode",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Flow Diagram\n\nLast Updated: Friday, September 8, 2023 at 7:18:52 PM PDT\n\n```mermaid\ngraph TD;\nstyle Start fill:#228B22, stroke:#000000, stroke-width:2px;\nstyle ExampleProcess fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle ExampleErrorPath fill:#B22222, stroke:#000000, stroke-width:2px;\n\nStart-->ExampleProcess;\nStart-->ExampleErrorPath;\nExampleProcess-->End;\nExampleErrorPath-->End;\n```\n\nThe code provided does not contain any control flow."
            }
          ],
          "metadata": {
            "outputType": "flowDiagram",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Security Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:19:20 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "bugAnalysisList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Performance Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:19:39 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "performanceList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Data and Privacy Compliance Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:21:40 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "complianceCodeList",
            "details": []
          }
        }
      ],
      "languageId": "typescript",
      "id": "0",
      "value": "import { expect } from \"chai\";\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 0
      }
    },
    {
      "outputs": [
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Code Explanation\n\nLast Updated: Friday, September 8, 2023 at 7:17:52 PM PDT\n\nThis code is written in JavaScript or TypeScript, which are both commonly used languages for developing web and server applications and for scripting in various environments.\n\nThe code snippet you've provided is a simple import statement. It's importing three items from a module located at \"../../utilities/workflow_engine\". The items being imported are:\n\n1. `PromiseGenerator`: This could be a function or a class that generates and returns a Promise. Promises in JavaScript represent a value that may not be available yet, but will be resolved at some point in the future. They are often used for asynchronous operations, such as network requests. You can learn more about promises here: [MDN Web Docs - Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n2. `WorkflowEngine`: This could be a class or an object that handles the execution of workflows. A workflow, in the context of software, typically represents a series of tasks that are performed in a specific order. The WorkflowEngine would be responsible for managing these tasks and ensuring they are performed correctly. \n\n3. `WorkflowError`: This is likely a custom error class that's used to represent errors that occur while executing a workflow. Custom error classes can be used to provide more specific error information and to handle specific types of errors in a more controlled way. You can learn more about error handling in JavaScript here: [MDN Web Docs - Error handling](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#exception_handling_statements)\n\nThe specific algorithms used in these classes or functions can't be determined from this code snippet alone, as it only shows the import statement. The actual implementation of these items would be found in the file at \"../../utilities/workflow_engine\".\n\nAs for architectural guidelines, this code snippet is too small to make any definitive statements. However, the use of a separate module for workflow-related utilities suggests a modular architecture, which is a commonly used architectural pattern that promotes separation of concerns and makes the codebase easier to maintain and understand."
            }
          ],
          "metadata": {
            "outputType": "explainCode",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Flow Diagram\n\nLast Updated: Friday, September 8, 2023 at 7:18:57 PM PDT\n\n```mermaid\ngraph TD;\nstyle Start fill:#228B22, stroke:#000000, stroke-width:2px;\nstyle PromiseGenerator fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle WorkflowEngine fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle WorkflowError fill:#B22222, stroke:#000000, stroke-width:2px;\n\nStart-->PromiseGenerator;\nPromiseGenerator-->WorkflowEngine;\nWorkflowEngine-->WorkflowError;\n```"
            }
          ],
          "metadata": {
            "outputType": "flowDiagram",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Security Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:19:23 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "bugAnalysisList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Performance Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:19:43 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "performanceList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Data and Privacy Compliance Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:21:44 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "complianceCodeList",
            "details": []
          }
        }
      ],
      "languageId": "typescript",
      "id": "1",
      "value": "import { PromiseGenerator, WorkflowEngine, WorkflowError } from \"../../utilities/workflow_engine\";\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 1
      }
    },
    {
      "outputs": [
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Code Explanation\n\nLast Updated: Friday, September 8, 2023 at 7:18:42 PM PDT\n\nThis code is a set of test cases for a `WorkflowEngine` class. The `WorkflowEngine` class is not defined in this code, but from the context, we can infer that it is designed to execute a series of tasks (represented as Promises) in a specific order, with optional hooks for actions to take before the run, after each task, after each group of tasks, and after the run. \n\nThe tests are written using the Mocha testing framework, and Chai for assertions. Here are the details of the tests:\n\n1. **\"should run promises in the correct order\"**: This test verifies that the tasks are executed in the correct order. It also checks that the hooks (`beforeRun`, `afterEachTask`, `afterEachTaskGroup`, and `afterRun`) are called at the appropriate times.\n\n2. **\"Simulate N files processed in the correct order\"**: This test simulates the processing of a set of files. It checks that the files are processed in the correct order, and that the `afterEachTaskGroup` hook is called after each group of tasks.\n\n3. **\"should handle closure state properly\"**: This test checks whether the engine can handle closures correctly. It generates a series of tasks that return random numbers, and a summary task that sums these numbers. It checks that the sum calculated by the summary task matches the actual sum of the numbers.\n\n4. **\"should retry on 'retry' type error\"** and **\"should retry on generic task error\"**: These tests check that the engine correctly retries a task when a `retry` type `WorkflowError` or a generic error is thrown.\n\n5. **\"should skip on 'skip' type error\"**: This test checks that the engine skips a task when a `skip` type `WorkflowError` is thrown.\n\n6. **\"should abort on 'abort' type error\"** and **\"should abort on 'abort' beforeRun abort\"**: These tests check that the engine aborts the run when an `abort` type `WorkflowError` is thrown.\n\n7. **\"should cancel on 'cancel' type error\"**: This test checks that the engine cancels the run when a `cancel` type `WorkflowError` is thrown.\n\n8. **\"should allow a 'then' after run command\"**: This test checks that the `run` method of the engine returns a `Promise` that can be chained with `then`.\n\n9. **\"should respect maxRetries option with WorkflowError\"** and **\"should respect maxRetries option with Generic Error\"**: These tests check that the engine respects the `maxRetries` option when a `retry` type `WorkflowError` or a generic error is thrown.\n\nFor more information about Mocha and Chai, you can refer to their documentation:\n\n- Mocha: [https://mochajs.org/](https://mochajs.org/)\n- Chai: [https://www.chaijs.com/](https://www.chaijs.com/) \n\nFor more information about Promises and asynchronous programming in JavaScript, you can refer to the MDN Web Docs:\n\n- Promises: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n- Asynchronous programming: [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous)"
            }
          ],
          "metadata": {
            "outputType": "explainCode",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Flow Diagram\n\nLast Updated: Friday, September 8, 2023 at 7:19:12 PM PDT\n\n```mermaid\ngraph TD;\nstyle Start fill:#228B22, stroke:#000000, stroke-width:2px;\nstyle ExampleProcess fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle ExampleErrorPath fill:#B22222, stroke:#000000, stroke-width:2px;\nstyle ExampleProcess fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle ExampleErrorPath fill:#B22222, stroke:#000000, stroke-width:2px;\n\nStart-->beforeRun;\nbeforeRun-->main1;\nmain1-->afterEachTaskGroup;\nafterEachTaskGroup-->main2;\nmain2-->main3;\nmain3-->afterEachTaskGroup;\nafterEachTaskGroup-->main4;\nmain4-->afterEachTaskGroup;\nafterEachTaskGroup-->afterRun;\nafterRun-->End;\n\nStart-->beforeRun2;\nbeforeRun2-->Processedfile1;\nProcessedfile1-->afterEachTaskGroup2;\nafterEachTaskGroup2-->Processedfile2;\nProcessedfile2-->Processedfile3;\nProcessedfile3-->afterEachTaskGroup2;\nafterEachTaskGroup2-->Processedfile4;\nProcessedfile4-->Processedfile5;\nProcessedfile5-->afterEachTaskGroup2;\nafterEachTaskGroup2-->Processedfile6;\nProcessedfile6-->Processedfile7;\nProcessedfile7-->afterEachTaskGroup2;\nafterEachTaskGroup2-->Processedfile8;\nProcessedfile8-->Processedfile9;\nProcessedfile9-->afterEachTaskGroup2;\nafterEachTaskGroup2-->Processedfile10;\nProcessedfile10-->afterEachTaskGroup2;\nafterEachTaskGroup2-->afterRun2;\nafterRun2-->End;\n\nStart-->main1;\nmain1-->main2;\nmain2-->main3;\nmain3-->main4;\nmain4-->afterEachTaskGroup3;\nafterEachTaskGroup3-->afterRun3;\nafterRun3-->End;\n\nStart-->main1;\nmain1-->main2;\nmain2-->main3;\nmain3-->main4;\nmain4-->afterEachTaskGroup4;\nafterEachTaskGroup4-->afterRun4;\nafterRun\n\n```mermaid\ngraph TD;\nstyle Start fill:#228B22, stroke:#000000, stroke-width:2px;\nstyle ExampleProcess fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle ExampleErrorPath fill:#B22222, stroke:#000000, stroke-width:2px;\n\nStart-->ExampleProcess;\nStart-->ExampleErrorPath;\nExampleProcess-->End;\nExampleErrorPath-->End;\n```\n\nThe code provided does not contain any control flow."
            }
          ],
          "metadata": {
            "outputType": "flowDiagram",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Security Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:19:28 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "bugAnalysisList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Performance Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:20:55 PM PDT\n\n1. **Severity**: 5/10\n\n   **Line Number**: 22\n\n   **Bug Type**: CPU\n\n   **Description**: The use of console.log within the afterEachTask could cause unnecessary CPU usage if log grows large.\n\n   **Solution**: Consider removing console.log or limit its usage to keep CPU usage optimal. Alternatively, use a logging library that can handle large logs efficiently.\n\n\n2. **Severity**: 5/10\n\n   **Line Number**: 51\n\n   **Bug Type**: CPU\n\n   **Description**: The use of console.log within the afterEachTask could cause unnecessary CPU usage if log grows large.\n\n   **Solution**: Consider removing console.log or limit its usage to keep CPU usage optimal. Alternatively, use a logging library that can handle large logs efficiently.\n\n\n3. **Severity**: 4/10\n\n   **Line Number**: 86\n\n   **Bug Type**: Memory\n\n   **Description**: The array randomNumbers is filled with random numbers and it's size can grow indefinitely depending on the input, which can lead to memory issues.\n\n   **Solution**: Ensure that the size of randomNumbers array is controlled and does not grow indefinitely. Consider using a data structure that has a fixed size.\n\n\n4. **Severity**: 6/10\n\n   **Line Number**: 103\n\n   **Bug Type**: CPU\n\n   **Description**: The use of reduce function within the summaryPromiseGenerator could cause high CPU usage if inputs array grows large.\n\n   **Solution**: Consider optimizing the reduce function or limit the size of the inputs array to keep CPU usage optimal.\n\n\n5. **Severity**: 7/10\n\n   **Line Number**: 151\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n6. **Severity**: 7/10\n\n   **Line Number**: 211\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n7. **Severity**: 7/10\n\n   **Line Number**: 294\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n8. **Severity**: 7/10\n\n   **Line Number**: 329\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n9. **Severity**: 7/10\n\n   **Line Number**: 363\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n10. **Severity**: 7/10\n\n   **Line Number**: 401\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n11. **Severity**: 7/10\n\n   **Line Number**: 439\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n12. **Severity**: 7/10\n\n   **Line Number**: 484\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n13. **Severity**: 7/10\n\n   **Line Number**: 527\n\n   **Bug Type**: CPU\n\n   **Description**: The use of deep.equal within the expect function could cause high CPU usage if log array grows large.\n\n   **Solution**: Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal.\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "performanceList",
            "details": [
              {
                "lineNumber": 20,
                "severity": 5,
                "bugType": "CPU",
                "description": "The use of console.log within the afterEachTask could cause unnecessary CPU usage if log grows large.",
                "solution": "Consider removing console.log or limit its usage to keep CPU usage optimal. Alternatively, use a logging library that can handle large logs efficiently."
              },
              {
                "lineNumber": 49,
                "severity": 5,
                "bugType": "CPU",
                "description": "The use of console.log within the afterEachTask could cause unnecessary CPU usage if log grows large.",
                "solution": "Consider removing console.log or limit its usage to keep CPU usage optimal. Alternatively, use a logging library that can handle large logs efficiently."
              },
              {
                "lineNumber": 84,
                "severity": 4,
                "bugType": "Memory",
                "description": "The array randomNumbers is filled with random numbers and it's size can grow indefinitely depending on the input, which can lead to memory issues.",
                "solution": "Ensure that the size of randomNumbers array is controlled and does not grow indefinitely. Consider using a data structure that has a fixed size."
              },
              {
                "lineNumber": 101,
                "severity": 6,
                "bugType": "CPU",
                "description": "The use of reduce function within the summaryPromiseGenerator could cause high CPU usage if inputs array grows large.",
                "solution": "Consider optimizing the reduce function or limit the size of the inputs array to keep CPU usage optimal."
              },
              {
                "lineNumber": 149,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 209,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 292,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 327,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 361,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 399,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 437,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 482,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              },
              {
                "lineNumber": 525,
                "severity": 7,
                "bugType": "CPU",
                "description": "The use of deep.equal within the expect function could cause high CPU usage if log array grows large.",
                "solution": "Consider optimizing the deep.equal function or limit the size of the log array to keep CPU usage optimal."
              }
            ]
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Data and Privacy Compliance Analysis\n\nLast Updated: Friday, September 8, 2023 at 7:21:48 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "complianceCodeList",
            "details": []
          }
        }
      ],
      "languageId": "typescript",
      "id": "2",
      "value": "\ndescribe(\"WorkflowEngine\", () => {\n    it(\"should run promises in the correct order\", function (done) {\n        let log: string[] = [];\n\n        const beforeRun = [\n            () => async () => {\n                log.push(\"beforeRun\");\n                return;\n            },\n        ];\n        const tasks = [\n            () => async () => {\n                log.push(\"main1\");\n                return 1;\n            },\n            () => async () => {\n                log.push(\"main2\");\n                return 2;\n            },\n            () => async () => {\n                log.push(\"main3\");\n                return 3;\n            },\n            () => async () => {\n                log.push(\"main4\");\n                return 4;\n            },\n        ];\n        const afterEachTask = [\n            () => async () => {\n                console.log(log);\n                return;\n            },\n        ];\n        const afterEachTaskGroup = [\n            () => async () => {\n                log.push(\"afterEachTaskGroup\");\n                return;\n            },\n        ];\n        const afterRun = [\n            () => async () => {\n                log.push(\"afterRun\");\n                return;\n            },\n        ];\n\n        const pattern = [1, 2];\n\n        const engine = new WorkflowEngine(tasks, {\n            beforeRun: beforeRun,\n            afterEachTask: afterEachTask,\n            afterEachTaskGroup: afterEachTaskGroup,\n            afterRun: afterRun,\n            pattern: pattern,\n            name: (this as any).test.title,\n        });\n\n        engine.run().then(allResults => {\n            expect(allResults.length).to.equal(3);\n\n            expect(allResults[0].length).to.equal(1);\n            expect(allResults[0][0]).to.equal(1);\n    \n            expect(allResults[1].length).to.equal(2);\n            expect(allResults[1][0]).to.equal(2);\n            expect(allResults[1][1]).to.equal(3);\n    \n            expect(allResults[2].length).to.equal(1);\n            expect(allResults[2][0]).to.equal(4);\n    \n            expect(log).to.deep.equal([\n                \"beforeRun\",\n                \"main1\",\n                \"afterEachTaskGroup\",\n                \"main2\",\n                \"main3\",\n                \"afterEachTaskGroup\",\n                \"main4\",\n                \"afterEachTaskGroup\",\n                \"afterRun\",\n            ]);\n            done(); // We use done to tell Mocha that our test has completed\n        }).catch(err => {\n            done(err); // Pass the error to done() to handle test failure\n        });\n\n    });\n\n    it(\"Simulate N files processed in the correct order\", function () {\n        let log: string[] = [];\n\n        const beforeRun = [\n            () => async () => {\n                log.push(\"beforeRun\");\n                return;\n            },\n        ];\n        const files = [\"file1\", \"file2\", \"file3\", \"file4\", \"file5\", \"file6\", \"file7\", \"file8\", \"file9\", \"file10\"];\n        const tasks : PromiseGenerator[] =\n            files.map((file) => {\n                return () => {\n                    return async () => {\n                        return new Promise<string>(\n                            (resolve, reject) => {\n                                try\n                                {\n                                    log.push(`Processed: ${file}`);\n                                    resolve(file);\n                                } catch (error) {\n                                    reject(error);\n                                }\n                            });\n                        };\n                    };\n            });\n        const afterEachTask = [\n            () => async () => {\n                console.log(log);\n                return;\n            },\n        ];\n        const afterEachTaskGroup = [\n            () => async () => {\n                log.push(\"afterEachTaskGroup\");\n                return;\n            },\n        ];\n        const afterRun = [\n            () => async () => {\n                log.push(\"afterRun\");\n                return;\n            },\n        ];\n\n        const pattern = [1, 2];\n\n        const engine = new WorkflowEngine(tasks as PromiseGenerator[], {\n            beforeRun: beforeRun,\n            afterEachTask: afterEachTask,\n            afterEachTaskGroup: afterEachTaskGroup,\n            afterRun: afterRun,\n            pattern: pattern,\n            name: (this as any).test.title,\n        });\n        return engine.run().then(() => {\n\n            expect(log).to.deep.equal(\n                [\n                    \"beforeRun\",\n                    \"Processed: file1\",\n                    \"afterEachTaskGroup\",\n                    \"Processed: file2\",\n                    \"Processed: file3\",\n                    \"afterEachTaskGroup\",\n                    \"Processed: file4\",\n                    \"Processed: file5\",\n                    \"afterEachTaskGroup\",\n                    \"Processed: file6\",\n                    \"Processed: file7\",\n                    \"afterEachTaskGroup\",\n                    \"Processed: file8\",\n                    \"Processed: file9\",\n                    \"afterEachTaskGroup\",\n                    \"Processed: file10\",\n                    \"afterEachTaskGroup\",\n                    \"afterRun\",\n                ]\n            );\n        });\n    });\n\n    // More tests can be written to verify other functionalities...\n    it(\"should handle closure state properly\", function () {\n        //create an array of 5 random numbers\n        let randomNumbers: number[] = [];\n        for (let i = 0; i < 5; i++) {\n            //create a random number that is an integer between 0 and 100\n            randomNumbers.push(Math.floor(Math.random() * 100));\n        }\n        //get the sum for double checking\n        let sum = randomNumbers.reduce((a, b) => a + b, 0);\n        //now put each number into a promise generator\n        let promiseGenerators: (() => () => Promise<number>)[] = [];\n        for (let i = 0; i < 5; i++) {\n            promiseGenerators.push(() => {\n                return async () => {\n                    return randomNumbers[i];\n                };\n            });\n        }\n        //now create a summary promise generator. use a closure to keep track of the sum, with a variable here on\n        //the outside of the closure to check the sum later\n        let sumCheck = 0;\n        let summaryPromiseGenerator = () => {\n            return async (inputs: any[]) => {\n                //the inputs are the results of the previous promises\n                sumCheck += inputs.reduce((a: number, b: number) => a + b, 0);\n                return sumCheck as any;\n            };\n        };\n        //now create the engine\n        const engine : WorkflowEngine = new WorkflowEngine(promiseGenerators, {\n            afterEachTaskGroup: [summaryPromiseGenerator],\n            name: (this as any).test.title,\n        });\n        //run the engine\n        return engine.run().then(() => {\n            //check the sum\n            expect(sumCheck).to.equal(sum);\n        });\n    });\n\n    it('should retry on \"retry\" type error', function(done) {\n        let log : any[] = []; // To track what happened\n        let retryCount = 0; // To count how many times we retried\n    \n        // Define the tasks array\n        const tasks = [\n            () => async () => {\n                if (retryCount < 2) {\n                    retryCount++;\n                    throw new WorkflowError(\"retry\", \"Retry error\");\n                } else {\n                    log.push(\"main\");\n                    return \"main\";\n                }\n            }\n        ];\n    \n        const engine = new WorkflowEngine(tasks, { name: (this as any).test.title });\n    \n        engine.run().then(allResults => {\n            expect(allResults.length).to.equal(1);\n            expect(allResults[0].length).to.equal(1);\n            expect(allResults[0][0]).to.equal(\"main\");\n    \n            expect(log).to.deep.equal([\"main\"]);\n            expect(retryCount).to.equal(2);\n    \n            done();\n        }).catch(err => {\n            done(err); // If there's an error, pass it to done to fail the test\n        });\n    });\n    \n\n    it('should retry on generic task error', function () {\n        let log: string[] = [];\n        let retryCount = 0;\n\n        const tasks = [\n            () => async () => {\n                if (retryCount < 2) {\n                    retryCount++;\n                    throw new Error(\"Test Generic Error retry\");\n                } else {\n                    log.push(\"main\");\n                }\n            },\n        ];\n\n        const engine : WorkflowEngine = new WorkflowEngine(tasks, { name: (this as any).test.title });\n        return engine.run().then(() => {\n            expect(log).to.deep.equal([\"main\"]);\n            expect(retryCount).to.equal(2);\n        });\n    });\n\n    it('should skip on \"skip\" type error', function () {\n        let log: string[] = [];\n    \n        const tasks = [\n            () => async () => {\n                throw new WorkflowError(\"skip\", \"Skip error\");\n            },\n            () => async () => {\n                log.push(\"main\");\n                return \"main\";\n            },\n        ];\n    \n        const afterRun = [\n            () => async (taskResults: any[]) => {\n                expect(taskResults.length).to.equal(2);\n                expect(taskResults[0].length).to.equal(1);\n                expect(taskResults[0][0] instanceof WorkflowError).to.equal(true);\n                expect(taskResults[0][0].type).to.equal(\"skip\");\n        \n                expect(taskResults[1].length).to.equal(1);\n                expect(taskResults[1][0]).to.equal(\"main\");\n                return;\n            },\n        ];\n    \n        const engine : WorkflowEngine = new WorkflowEngine(tasks, {\n                afterRun: afterRun,\n                name: (this as any).test.title,\n            });\n    \n        return engine.run().then(allResults => {\n            afterRun[0]()(allResults);\n            expect(log).to.deep.equal([\"main\"]);\n        });\n    });    \n\n    it('should abort on \"abort\" type error', function() {\n        let log: string[] = [];\n    \n        const tasks = [\n            () => async () => {\n                throw new WorkflowError(\"abort\", \"Abort error\");\n            },\n            () => async () => {\n                log.push(\"main\");\n            },\n        ];\n    \n        const engine : WorkflowEngine = new WorkflowEngine(tasks, { name: (this as any).test.title });\n        return engine.run().then(allResults => {\n            expect(allResults.length).to.equal(1);\n            expect(allResults[0].length).to.equal(1);\n            expect(allResults[0][0] instanceof WorkflowError).to.equal(true);\n    \n            expect(log).to.deep.equal([]);\n        });\n    });\n\n    it('should abort on \"abort\" beforeRun abort', function() {\n        let log: string[] = [];\n    \n        const beforeRun = [\n            () => async () => {\n                throw new WorkflowError(\"abort\", \"Abort error\");\n            },\n        ];\n\n        const tasks = [\n            () => async () => {\n                log.push(\"main1\");\n                return \"main1\";\n            },\n            () => async () => {\n                throw new WorkflowError(\"cancel\", \"Cancel error\");\n            },\n            () => async () => {\n                log.push(\"main2\");\n                return \"main2\";\n            },\n        ];\n\n        const engine : WorkflowEngine = new WorkflowEngine(tasks,{\n            name: (this as any).test.title,\n            beforeRun: beforeRun });\n        return engine.run().then(allResults => {\n            expect(allResults.length).to.equal(1);\n            expect(allResults[0] instanceof WorkflowError).to.equal(true);\n    \n            expect(log).to.deep.equal([]);\n        });\n    });\n    \n    it('should cancel on \"cancel\" type error', function() {\n        let log: string[] = [];\n    \n        const tasks = [\n            () => async () => {\n                log.push(\"main1\");\n                return \"main1\";\n            },\n            () => async () => {\n                throw new WorkflowError(\"cancel\", \"Cancel error\");\n            },\n            () => async () => {\n                log.push(\"main2\");\n                return \"main2\";\n            },\n        ];\n    \n        const beforeRun = [\n            () => async () => {\n                log.push(\"beforeRun\");\n                return;\n            },\n        ];\n        const afterEachTask = [\n            () => async () => {\n                log.push(\"afterEachTask\");\n                return;\n            },\n        ];\n        const afterEachTaskGroup = [\n            () => async () => {\n                log.push(\"afterEachTaskGroup\");\n                return;\n            },\n        ];\n        const afterRun = [\n            () => async () => {\n                log.push(\"afterRun\");\n                return;\n            },\n        ];\n    \n        const engine : WorkflowEngine = new WorkflowEngine(tasks,\n            {\n                beforeRun: beforeRun,\n                afterEachTask: afterEachTask,\n                afterEachTaskGroup: afterEachTaskGroup,\n                afterRun: afterRun,\n                name: (this as any).test.title,\n            });\n        return engine.run().then(allResults => {\n            expect(allResults.length).to.equal(2);\n            expect(allResults[0].length).to.equal(1);\n            expect(allResults[0][0]).to.equal(\"main1\");\n            expect(allResults[1].length).to.equal(1);\n            expect(allResults[1][0] instanceof WorkflowError).to.equal(true);\n    \n            expect(log).to.deep.equal([\n                \"beforeRun\",\n                \"main1\",\n                \"afterEachTask\",\n                \"afterEachTaskGroup\",\n                \"afterEachTaskGroup\",\n                \"afterRun\",\n            ]);\n        });\n    });    \n    \n    it(\"should allow a 'then' after run command\", function() {\n        const engine : WorkflowEngine = new WorkflowEngine([], { name: (this as any).test.title });\n        const result = engine.run();\n    \n        // Check if run() returns a Promise\n        expect(result).to.be.an.instanceOf(Promise);\n    \n        let thenWorked = false;\n    \n        // Here, we're using the done() function provided by Mocha to handle asynchronous tests.\n        return result.then(() => { \n            thenWorked = true;\n            expect(thenWorked).to.be.true;\n        });\n    });\n\n    it(\"should respect maxRetries option with WorkflowError\", function () {\n        let log: string[] = [];\n        let executionCount = 0;\n\n        const tasks = [\n            () => async () => {\n                if (executionCount < 4) {\n                    executionCount++;\n                    throw new WorkflowError(\"retry\", \"Retry error\");\n                } else {\n                    log.push(\"main\");\n                }\n            },\n        ];\n\n        const engine : WorkflowEngine = new WorkflowEngine(tasks, {\n            maxRetries: 1,\n            name: (this as any).test.title,\n        }); // Setting maxRetries to 1 should only retry once\n        return engine.run().then(() => {\n            expect(engine.currentTaskRetries).to.equal(0); // retry count should be reset\n\n            expect(log).to.deep.equal([]); // Since maxRetries is 1, the promise should not be successful and \"main\" won't be logged\n            expect(executionCount).to.equal(3); // Should only retry 1 times, so total executions is 3\n        });\n    });\n\n    it(\"should respect maxRetries option with Generic Error\", function () {\n        let log: string[] = [];\n        let executionCount = 0;\n\n        const tasks = [\n            () => async () => {\n                if (executionCount < 4) {\n                    executionCount++;\n                    throw new Error(\"Unknown Error object - to test general retry\");\n                } else {\n                    log.push(\"main\");\n                }\n            },\n        ];\n\n        const engine : WorkflowEngine = new WorkflowEngine(tasks, {\n            maxRetries: 1,\n            name: (this as any).test.title,\n        }); // Setting maxRetries to 1 should only retry once\n        return engine.run().then(() => {\n            expect(engine.currentTaskRetries).to.equal(0); // retry count should be reset\n\n            expect(log).to.deep.equal([]); // Since maxRetries is 1, the promise should not be successful and \"main\" won't be logged\n            expect(executionCount).to.equal(3); // Should only retry 1 times, so total executions is 3\n        });\n    });});\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 2
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./src/test/unit/workflow_engine.test.ts"
  }
}